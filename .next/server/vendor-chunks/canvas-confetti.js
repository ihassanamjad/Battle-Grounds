"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/canvas-confetti";
exports.ids = ["vendor-chunks/canvas-confetti"];
exports.modules = {

/***/ "(ssr)/./node_modules/canvas-confetti/dist/confetti.module.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/canvas-confetti/dist/confetti.module.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   create: () => (/* binding */ create),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n// canvas-confetti v1.9.3 built on 2024-04-30T22:19:17.794Z\nvar module = {};\n// source content\n/* globals Map */ (function main(global, module, isWorker, workerSize) {\n    var canUseWorker = !!(global.Worker && global.Blob && global.Promise && global.OffscreenCanvas && global.OffscreenCanvasRenderingContext2D && global.HTMLCanvasElement && global.HTMLCanvasElement.prototype.transferControlToOffscreen && global.URL && global.URL.createObjectURL);\n    var canUsePaths = typeof Path2D === \"function\" && typeof DOMMatrix === \"function\";\n    var canDrawBitmap = function() {\n        // this mostly supports ssr\n        if (!global.OffscreenCanvas) {\n            return false;\n        }\n        var canvas = new OffscreenCanvas(1, 1);\n        var ctx = canvas.getContext(\"2d\");\n        ctx.fillRect(0, 0, 1, 1);\n        var bitmap = canvas.transferToImageBitmap();\n        try {\n            ctx.createPattern(bitmap, \"no-repeat\");\n        } catch (e) {\n            return false;\n        }\n        return true;\n    }();\n    function noop() {}\n    // create a promise if it exists, otherwise, just\n    // call the function directly\n    function promise(func) {\n        var ModulePromise = module.exports.Promise;\n        var Prom = ModulePromise !== void 0 ? ModulePromise : global.Promise;\n        if (typeof Prom === \"function\") {\n            return new Prom(func);\n        }\n        func(noop, noop);\n        return null;\n    }\n    var bitmapMapper = function(skipTransform, map) {\n        // see https://github.com/catdad/canvas-confetti/issues/209\n        // creating canvases is actually pretty expensive, so we should create a\n        // 1:1 map for bitmap:canvas, so that we can animate the confetti in\n        // a performant manner, but also not store them forever so that we don't\n        // have a memory leak\n        return {\n            transform: function(bitmap) {\n                if (skipTransform) {\n                    return bitmap;\n                }\n                if (map.has(bitmap)) {\n                    return map.get(bitmap);\n                }\n                var canvas = new OffscreenCanvas(bitmap.width, bitmap.height);\n                var ctx = canvas.getContext(\"2d\");\n                ctx.drawImage(bitmap, 0, 0);\n                map.set(bitmap, canvas);\n                return canvas;\n            },\n            clear: function() {\n                map.clear();\n            }\n        };\n    }(canDrawBitmap, new Map());\n    var raf = function() {\n        var TIME = Math.floor(1000 / 60);\n        var frame, cancel;\n        var frames = {};\n        var lastFrameTime = 0;\n        if (typeof requestAnimationFrame === \"function\" && typeof cancelAnimationFrame === \"function\") {\n            frame = function(cb) {\n                var id = Math.random();\n                frames[id] = requestAnimationFrame(function onFrame(time) {\n                    if (lastFrameTime === time || lastFrameTime + TIME - 1 < time) {\n                        lastFrameTime = time;\n                        delete frames[id];\n                        cb();\n                    } else {\n                        frames[id] = requestAnimationFrame(onFrame);\n                    }\n                });\n                return id;\n            };\n            cancel = function(id) {\n                if (frames[id]) {\n                    cancelAnimationFrame(frames[id]);\n                }\n            };\n        } else {\n            frame = function(cb) {\n                return setTimeout(cb, TIME);\n            };\n            cancel = function(timer) {\n                return clearTimeout(timer);\n            };\n        }\n        return {\n            frame: frame,\n            cancel: cancel\n        };\n    }();\n    var getWorker = function() {\n        var worker;\n        var prom;\n        var resolves = {};\n        function decorate(worker) {\n            function execute(options, callback) {\n                worker.postMessage({\n                    options: options || {},\n                    callback: callback\n                });\n            }\n            worker.init = function initWorker(canvas) {\n                var offscreen = canvas.transferControlToOffscreen();\n                worker.postMessage({\n                    canvas: offscreen\n                }, [\n                    offscreen\n                ]);\n            };\n            worker.fire = function fireWorker(options, size, done) {\n                if (prom) {\n                    execute(options, null);\n                    return prom;\n                }\n                var id = Math.random().toString(36).slice(2);\n                prom = promise(function(resolve) {\n                    function workerDone(msg) {\n                        if (msg.data.callback !== id) {\n                            return;\n                        }\n                        delete resolves[id];\n                        worker.removeEventListener(\"message\", workerDone);\n                        prom = null;\n                        bitmapMapper.clear();\n                        done();\n                        resolve();\n                    }\n                    worker.addEventListener(\"message\", workerDone);\n                    execute(options, id);\n                    resolves[id] = workerDone.bind(null, {\n                        data: {\n                            callback: id\n                        }\n                    });\n                });\n                return prom;\n            };\n            worker.reset = function resetWorker() {\n                worker.postMessage({\n                    reset: true\n                });\n                for(var id in resolves){\n                    resolves[id]();\n                    delete resolves[id];\n                }\n            };\n        }\n        return function() {\n            if (worker) {\n                return worker;\n            }\n            if (!isWorker && canUseWorker) {\n                var code = [\n                    \"var CONFETTI, SIZE = {}, module = {};\",\n                    \"(\" + main.toString() + \")(this, module, true, SIZE);\",\n                    \"onmessage = function(msg) {\",\n                    \"  if (msg.data.options) {\",\n                    \"    CONFETTI(msg.data.options).then(function () {\",\n                    \"      if (msg.data.callback) {\",\n                    \"        postMessage({ callback: msg.data.callback });\",\n                    \"      }\",\n                    \"    });\",\n                    \"  } else if (msg.data.reset) {\",\n                    \"    CONFETTI && CONFETTI.reset();\",\n                    \"  } else if (msg.data.resize) {\",\n                    \"    SIZE.width = msg.data.resize.width;\",\n                    \"    SIZE.height = msg.data.resize.height;\",\n                    \"  } else if (msg.data.canvas) {\",\n                    \"    SIZE.width = msg.data.canvas.width;\",\n                    \"    SIZE.height = msg.data.canvas.height;\",\n                    \"    CONFETTI = module.exports.create(msg.data.canvas);\",\n                    \"  }\",\n                    \"}\"\n                ].join(\"\\n\");\n                try {\n                    worker = new Worker(URL.createObjectURL(new Blob([\n                        code\n                    ])));\n                } catch (e) {\n                    // eslint-disable-next-line no-console\n                    typeof console !== undefined && typeof console.warn === \"function\" ? console.warn(\"\\uD83C\\uDF8A Could not load worker\", e) : null;\n                    return null;\n                }\n                decorate(worker);\n            }\n            return worker;\n        };\n    }();\n    var defaults = {\n        particleCount: 50,\n        angle: 90,\n        spread: 45,\n        startVelocity: 45,\n        decay: 0.9,\n        gravity: 1,\n        drift: 0,\n        ticks: 200,\n        x: 0.5,\n        y: 0.5,\n        shapes: [\n            \"square\",\n            \"circle\"\n        ],\n        zIndex: 100,\n        colors: [\n            \"#26ccff\",\n            \"#a25afd\",\n            \"#ff5e7e\",\n            \"#88ff5a\",\n            \"#fcff42\",\n            \"#ffa62d\",\n            \"#ff36ff\"\n        ],\n        // probably should be true, but back-compat\n        disableForReducedMotion: false,\n        scalar: 1\n    };\n    function convert(val, transform) {\n        return transform ? transform(val) : val;\n    }\n    function isOk(val) {\n        return !(val === null || val === undefined);\n    }\n    function prop(options, name, transform) {\n        return convert(options && isOk(options[name]) ? options[name] : defaults[name], transform);\n    }\n    function onlyPositiveInt(number) {\n        return number < 0 ? 0 : Math.floor(number);\n    }\n    function randomInt(min, max) {\n        // [min, max)\n        return Math.floor(Math.random() * (max - min)) + min;\n    }\n    function toDecimal(str) {\n        return parseInt(str, 16);\n    }\n    function colorsToRgb(colors) {\n        return colors.map(hexToRgb);\n    }\n    function hexToRgb(str) {\n        var val = String(str).replace(/[^0-9a-f]/gi, \"\");\n        if (val.length < 6) {\n            val = val[0] + val[0] + val[1] + val[1] + val[2] + val[2];\n        }\n        return {\n            r: toDecimal(val.substring(0, 2)),\n            g: toDecimal(val.substring(2, 4)),\n            b: toDecimal(val.substring(4, 6))\n        };\n    }\n    function getOrigin(options) {\n        var origin = prop(options, \"origin\", Object);\n        origin.x = prop(origin, \"x\", Number);\n        origin.y = prop(origin, \"y\", Number);\n        return origin;\n    }\n    function setCanvasWindowSize(canvas) {\n        canvas.width = document.documentElement.clientWidth;\n        canvas.height = document.documentElement.clientHeight;\n    }\n    function setCanvasRectSize(canvas) {\n        var rect = canvas.getBoundingClientRect();\n        canvas.width = rect.width;\n        canvas.height = rect.height;\n    }\n    function getCanvas(zIndex) {\n        var canvas = document.createElement(\"canvas\");\n        canvas.style.position = \"fixed\";\n        canvas.style.top = \"0px\";\n        canvas.style.left = \"0px\";\n        canvas.style.pointerEvents = \"none\";\n        canvas.style.zIndex = zIndex;\n        return canvas;\n    }\n    function ellipse(context, x, y, radiusX, radiusY, rotation, startAngle, endAngle, antiClockwise) {\n        context.save();\n        context.translate(x, y);\n        context.rotate(rotation);\n        context.scale(radiusX, radiusY);\n        context.arc(0, 0, 1, startAngle, endAngle, antiClockwise);\n        context.restore();\n    }\n    function randomPhysics(opts) {\n        var radAngle = opts.angle * (Math.PI / 180);\n        var radSpread = opts.spread * (Math.PI / 180);\n        return {\n            x: opts.x,\n            y: opts.y,\n            wobble: Math.random() * 10,\n            wobbleSpeed: Math.min(0.11, Math.random() * 0.1 + 0.05),\n            velocity: opts.startVelocity * 0.5 + Math.random() * opts.startVelocity,\n            angle2D: -radAngle + (0.5 * radSpread - Math.random() * radSpread),\n            tiltAngle: (Math.random() * (0.75 - 0.25) + 0.25) * Math.PI,\n            color: opts.color,\n            shape: opts.shape,\n            tick: 0,\n            totalTicks: opts.ticks,\n            decay: opts.decay,\n            drift: opts.drift,\n            random: Math.random() + 2,\n            tiltSin: 0,\n            tiltCos: 0,\n            wobbleX: 0,\n            wobbleY: 0,\n            gravity: opts.gravity * 3,\n            ovalScalar: 0.6,\n            scalar: opts.scalar,\n            flat: opts.flat\n        };\n    }\n    function updateFetti(context, fetti) {\n        fetti.x += Math.cos(fetti.angle2D) * fetti.velocity + fetti.drift;\n        fetti.y += Math.sin(fetti.angle2D) * fetti.velocity + fetti.gravity;\n        fetti.velocity *= fetti.decay;\n        if (fetti.flat) {\n            fetti.wobble = 0;\n            fetti.wobbleX = fetti.x + 10 * fetti.scalar;\n            fetti.wobbleY = fetti.y + 10 * fetti.scalar;\n            fetti.tiltSin = 0;\n            fetti.tiltCos = 0;\n            fetti.random = 1;\n        } else {\n            fetti.wobble += fetti.wobbleSpeed;\n            fetti.wobbleX = fetti.x + 10 * fetti.scalar * Math.cos(fetti.wobble);\n            fetti.wobbleY = fetti.y + 10 * fetti.scalar * Math.sin(fetti.wobble);\n            fetti.tiltAngle += 0.1;\n            fetti.tiltSin = Math.sin(fetti.tiltAngle);\n            fetti.tiltCos = Math.cos(fetti.tiltAngle);\n            fetti.random = Math.random() + 2;\n        }\n        var progress = fetti.tick++ / fetti.totalTicks;\n        var x1 = fetti.x + fetti.random * fetti.tiltCos;\n        var y1 = fetti.y + fetti.random * fetti.tiltSin;\n        var x2 = fetti.wobbleX + fetti.random * fetti.tiltCos;\n        var y2 = fetti.wobbleY + fetti.random * fetti.tiltSin;\n        context.fillStyle = \"rgba(\" + fetti.color.r + \", \" + fetti.color.g + \", \" + fetti.color.b + \", \" + (1 - progress) + \")\";\n        context.beginPath();\n        if (canUsePaths && fetti.shape.type === \"path\" && typeof fetti.shape.path === \"string\" && Array.isArray(fetti.shape.matrix)) {\n            context.fill(transformPath2D(fetti.shape.path, fetti.shape.matrix, fetti.x, fetti.y, Math.abs(x2 - x1) * 0.1, Math.abs(y2 - y1) * 0.1, Math.PI / 10 * fetti.wobble));\n        } else if (fetti.shape.type === \"bitmap\") {\n            var rotation = Math.PI / 10 * fetti.wobble;\n            var scaleX = Math.abs(x2 - x1) * 0.1;\n            var scaleY = Math.abs(y2 - y1) * 0.1;\n            var width = fetti.shape.bitmap.width * fetti.scalar;\n            var height = fetti.shape.bitmap.height * fetti.scalar;\n            var matrix = new DOMMatrix([\n                Math.cos(rotation) * scaleX,\n                Math.sin(rotation) * scaleX,\n                -Math.sin(rotation) * scaleY,\n                Math.cos(rotation) * scaleY,\n                fetti.x,\n                fetti.y\n            ]);\n            // apply the transform matrix from the confetti shape\n            matrix.multiplySelf(new DOMMatrix(fetti.shape.matrix));\n            var pattern = context.createPattern(bitmapMapper.transform(fetti.shape.bitmap), \"no-repeat\");\n            pattern.setTransform(matrix);\n            context.globalAlpha = 1 - progress;\n            context.fillStyle = pattern;\n            context.fillRect(fetti.x - width / 2, fetti.y - height / 2, width, height);\n            context.globalAlpha = 1;\n        } else if (fetti.shape === \"circle\") {\n            context.ellipse ? context.ellipse(fetti.x, fetti.y, Math.abs(x2 - x1) * fetti.ovalScalar, Math.abs(y2 - y1) * fetti.ovalScalar, Math.PI / 10 * fetti.wobble, 0, 2 * Math.PI) : ellipse(context, fetti.x, fetti.y, Math.abs(x2 - x1) * fetti.ovalScalar, Math.abs(y2 - y1) * fetti.ovalScalar, Math.PI / 10 * fetti.wobble, 0, 2 * Math.PI);\n        } else if (fetti.shape === \"star\") {\n            var rot = Math.PI / 2 * 3;\n            var innerRadius = 4 * fetti.scalar;\n            var outerRadius = 8 * fetti.scalar;\n            var x = fetti.x;\n            var y = fetti.y;\n            var spikes = 5;\n            var step = Math.PI / spikes;\n            while(spikes--){\n                x = fetti.x + Math.cos(rot) * outerRadius;\n                y = fetti.y + Math.sin(rot) * outerRadius;\n                context.lineTo(x, y);\n                rot += step;\n                x = fetti.x + Math.cos(rot) * innerRadius;\n                y = fetti.y + Math.sin(rot) * innerRadius;\n                context.lineTo(x, y);\n                rot += step;\n            }\n        } else {\n            context.moveTo(Math.floor(fetti.x), Math.floor(fetti.y));\n            context.lineTo(Math.floor(fetti.wobbleX), Math.floor(y1));\n            context.lineTo(Math.floor(x2), Math.floor(y2));\n            context.lineTo(Math.floor(x1), Math.floor(fetti.wobbleY));\n        }\n        context.closePath();\n        context.fill();\n        return fetti.tick < fetti.totalTicks;\n    }\n    function animate(canvas, fettis, resizer, size, done) {\n        var animatingFettis = fettis.slice();\n        var context = canvas.getContext(\"2d\");\n        var animationFrame;\n        var destroy;\n        var prom = promise(function(resolve) {\n            function onDone() {\n                animationFrame = destroy = null;\n                context.clearRect(0, 0, size.width, size.height);\n                bitmapMapper.clear();\n                done();\n                resolve();\n            }\n            function update() {\n                if (isWorker && !(size.width === workerSize.width && size.height === workerSize.height)) {\n                    size.width = canvas.width = workerSize.width;\n                    size.height = canvas.height = workerSize.height;\n                }\n                if (!size.width && !size.height) {\n                    resizer(canvas);\n                    size.width = canvas.width;\n                    size.height = canvas.height;\n                }\n                context.clearRect(0, 0, size.width, size.height);\n                animatingFettis = animatingFettis.filter(function(fetti) {\n                    return updateFetti(context, fetti);\n                });\n                if (animatingFettis.length) {\n                    animationFrame = raf.frame(update);\n                } else {\n                    onDone();\n                }\n            }\n            animationFrame = raf.frame(update);\n            destroy = onDone;\n        });\n        return {\n            addFettis: function(fettis) {\n                animatingFettis = animatingFettis.concat(fettis);\n                return prom;\n            },\n            canvas: canvas,\n            promise: prom,\n            reset: function() {\n                if (animationFrame) {\n                    raf.cancel(animationFrame);\n                }\n                if (destroy) {\n                    destroy();\n                }\n            }\n        };\n    }\n    function confettiCannon(canvas, globalOpts) {\n        var isLibCanvas = !canvas;\n        var allowResize = !!prop(globalOpts || {}, \"resize\");\n        var hasResizeEventRegistered = false;\n        var globalDisableForReducedMotion = prop(globalOpts, \"disableForReducedMotion\", Boolean);\n        var shouldUseWorker = canUseWorker && !!prop(globalOpts || {}, \"useWorker\");\n        var worker = shouldUseWorker ? getWorker() : null;\n        var resizer = isLibCanvas ? setCanvasWindowSize : setCanvasRectSize;\n        var initialized = canvas && worker ? !!canvas.__confetti_initialized : false;\n        var preferLessMotion = typeof matchMedia === \"function\" && matchMedia(\"(prefers-reduced-motion)\").matches;\n        var animationObj;\n        function fireLocal(options, size, done) {\n            var particleCount = prop(options, \"particleCount\", onlyPositiveInt);\n            var angle = prop(options, \"angle\", Number);\n            var spread = prop(options, \"spread\", Number);\n            var startVelocity = prop(options, \"startVelocity\", Number);\n            var decay = prop(options, \"decay\", Number);\n            var gravity = prop(options, \"gravity\", Number);\n            var drift = prop(options, \"drift\", Number);\n            var colors = prop(options, \"colors\", colorsToRgb);\n            var ticks = prop(options, \"ticks\", Number);\n            var shapes = prop(options, \"shapes\");\n            var scalar = prop(options, \"scalar\");\n            var flat = !!prop(options, \"flat\");\n            var origin = getOrigin(options);\n            var temp = particleCount;\n            var fettis = [];\n            var startX = canvas.width * origin.x;\n            var startY = canvas.height * origin.y;\n            while(temp--){\n                fettis.push(randomPhysics({\n                    x: startX,\n                    y: startY,\n                    angle: angle,\n                    spread: spread,\n                    startVelocity: startVelocity,\n                    color: colors[temp % colors.length],\n                    shape: shapes[randomInt(0, shapes.length)],\n                    ticks: ticks,\n                    decay: decay,\n                    gravity: gravity,\n                    drift: drift,\n                    scalar: scalar,\n                    flat: flat\n                }));\n            }\n            // if we have a previous canvas already animating,\n            // add to it\n            if (animationObj) {\n                return animationObj.addFettis(fettis);\n            }\n            animationObj = animate(canvas, fettis, resizer, size, done);\n            return animationObj.promise;\n        }\n        function fire(options) {\n            var disableForReducedMotion = globalDisableForReducedMotion || prop(options, \"disableForReducedMotion\", Boolean);\n            var zIndex = prop(options, \"zIndex\", Number);\n            if (disableForReducedMotion && preferLessMotion) {\n                return promise(function(resolve) {\n                    resolve();\n                });\n            }\n            if (isLibCanvas && animationObj) {\n                // use existing canvas from in-progress animation\n                canvas = animationObj.canvas;\n            } else if (isLibCanvas && !canvas) {\n                // create and initialize a new canvas\n                canvas = getCanvas(zIndex);\n                document.body.appendChild(canvas);\n            }\n            if (allowResize && !initialized) {\n                // initialize the size of a user-supplied canvas\n                resizer(canvas);\n            }\n            var size = {\n                width: canvas.width,\n                height: canvas.height\n            };\n            if (worker && !initialized) {\n                worker.init(canvas);\n            }\n            initialized = true;\n            if (worker) {\n                canvas.__confetti_initialized = true;\n            }\n            function onResize() {\n                if (worker) {\n                    // TODO this really shouldn't be immediate, because it is expensive\n                    var obj = {\n                        getBoundingClientRect: function() {\n                            if (!isLibCanvas) {\n                                return canvas.getBoundingClientRect();\n                            }\n                        }\n                    };\n                    resizer(obj);\n                    worker.postMessage({\n                        resize: {\n                            width: obj.width,\n                            height: obj.height\n                        }\n                    });\n                    return;\n                }\n                // don't actually query the size here, since this\n                // can execute frequently and rapidly\n                size.width = size.height = null;\n            }\n            function done() {\n                animationObj = null;\n                if (allowResize) {\n                    hasResizeEventRegistered = false;\n                    global.removeEventListener(\"resize\", onResize);\n                }\n                if (isLibCanvas && canvas) {\n                    if (document.body.contains(canvas)) {\n                        document.body.removeChild(canvas);\n                    }\n                    canvas = null;\n                    initialized = false;\n                }\n            }\n            if (allowResize && !hasResizeEventRegistered) {\n                hasResizeEventRegistered = true;\n                global.addEventListener(\"resize\", onResize, false);\n            }\n            if (worker) {\n                return worker.fire(options, size, done);\n            }\n            return fireLocal(options, size, done);\n        }\n        fire.reset = function() {\n            if (worker) {\n                worker.reset();\n            }\n            if (animationObj) {\n                animationObj.reset();\n            }\n        };\n        return fire;\n    }\n    // Make default export lazy to defer worker creation until called.\n    var defaultFire;\n    function getDefaultFire() {\n        if (!defaultFire) {\n            defaultFire = confettiCannon(null, {\n                useWorker: true,\n                resize: true\n            });\n        }\n        return defaultFire;\n    }\n    function transformPath2D(pathString, pathMatrix, x, y, scaleX, scaleY, rotation) {\n        var path2d = new Path2D(pathString);\n        var t1 = new Path2D();\n        t1.addPath(path2d, new DOMMatrix(pathMatrix));\n        var t2 = new Path2D();\n        // see https://developer.mozilla.org/en-US/docs/Web/API/DOMMatrix/DOMMatrix\n        t2.addPath(t1, new DOMMatrix([\n            Math.cos(rotation) * scaleX,\n            Math.sin(rotation) * scaleX,\n            -Math.sin(rotation) * scaleY,\n            Math.cos(rotation) * scaleY,\n            x,\n            y\n        ]));\n        return t2;\n    }\n    function shapeFromPath(pathData) {\n        if (!canUsePaths) {\n            throw new Error(\"path confetti are not supported in this browser\");\n        }\n        var path, matrix;\n        if (typeof pathData === \"string\") {\n            path = pathData;\n        } else {\n            path = pathData.path;\n            matrix = pathData.matrix;\n        }\n        var path2d = new Path2D(path);\n        var tempCanvas = document.createElement(\"canvas\");\n        var tempCtx = tempCanvas.getContext(\"2d\");\n        if (!matrix) {\n            // attempt to figure out the width of the path, up to 1000x1000\n            var maxSize = 1000;\n            var minX = maxSize;\n            var minY = maxSize;\n            var maxX = 0;\n            var maxY = 0;\n            var width, height;\n            // do some line skipping... this is faster than checking\n            // every pixel and will be mostly still correct\n            for(var x = 0; x < maxSize; x += 2){\n                for(var y = 0; y < maxSize; y += 2){\n                    if (tempCtx.isPointInPath(path2d, x, y, \"nonzero\")) {\n                        minX = Math.min(minX, x);\n                        minY = Math.min(minY, y);\n                        maxX = Math.max(maxX, x);\n                        maxY = Math.max(maxY, y);\n                    }\n                }\n            }\n            width = maxX - minX;\n            height = maxY - minY;\n            var maxDesiredSize = 10;\n            var scale = Math.min(maxDesiredSize / width, maxDesiredSize / height);\n            matrix = [\n                scale,\n                0,\n                0,\n                scale,\n                -Math.round(width / 2 + minX) * scale,\n                -Math.round(height / 2 + minY) * scale\n            ];\n        }\n        return {\n            type: \"path\",\n            path: path,\n            matrix: matrix\n        };\n    }\n    function shapeFromText(textData) {\n        var text, scalar = 1, color = \"#000000\", // see https://nolanlawson.com/2022/04/08/the-struggle-of-using-native-emoji-on-the-web/\n        fontFamily = '\"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\", \"EmojiOne Color\", \"Android Emoji\", \"Twemoji Mozilla\", \"system emoji\", sans-serif';\n        if (typeof textData === \"string\") {\n            text = textData;\n        } else {\n            text = textData.text;\n            scalar = \"scalar\" in textData ? textData.scalar : scalar;\n            fontFamily = \"fontFamily\" in textData ? textData.fontFamily : fontFamily;\n            color = \"color\" in textData ? textData.color : color;\n        }\n        // all other confetti are 10 pixels,\n        // so this pixel size is the de-facto 100% scale confetti\n        var fontSize = 10 * scalar;\n        var font = \"\" + fontSize + \"px \" + fontFamily;\n        var canvas = new OffscreenCanvas(fontSize, fontSize);\n        var ctx = canvas.getContext(\"2d\");\n        ctx.font = font;\n        var size = ctx.measureText(text);\n        var width = Math.ceil(size.actualBoundingBoxRight + size.actualBoundingBoxLeft);\n        var height = Math.ceil(size.actualBoundingBoxAscent + size.actualBoundingBoxDescent);\n        var padding = 2;\n        var x = size.actualBoundingBoxLeft + padding;\n        var y = size.actualBoundingBoxAscent + padding;\n        width += padding + padding;\n        height += padding + padding;\n        canvas = new OffscreenCanvas(width, height);\n        ctx = canvas.getContext(\"2d\");\n        ctx.font = font;\n        ctx.fillStyle = color;\n        ctx.fillText(text, x, y);\n        var scale = 1 / scalar;\n        return {\n            type: \"bitmap\",\n            // TODO these probably need to be transfered for workers\n            bitmap: canvas.transferToImageBitmap(),\n            matrix: [\n                scale,\n                0,\n                0,\n                scale,\n                -width * scale / 2,\n                -height * scale / 2\n            ]\n        };\n    }\n    module.exports = function() {\n        return getDefaultFire().apply(this, arguments);\n    };\n    module.exports.reset = function() {\n        getDefaultFire().reset();\n    };\n    module.exports.create = confettiCannon;\n    module.exports.shapeFromPath = shapeFromPath;\n    module.exports.shapeFromText = shapeFromText;\n})(function() {\n    if (false) {}\n    if (typeof self !== \"undefined\") {\n        return self;\n    }\n    return this || {};\n}(), module, false);\n// end source content\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (module.exports);\nvar create = module.exports.create;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2FudmFzLWNvbmZldHRpL2Rpc3QvY29uZmV0dGkubW9kdWxlLm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBLDJEQUEyRDtBQUMzRCxJQUFJQSxTQUFTLENBQUM7QUFFZCxpQkFBaUI7QUFDakIsZUFBZSxHQUVkLFVBQVNDLEtBQUtDLE1BQU0sRUFBRUYsTUFBTSxFQUFFRyxRQUFRLEVBQUVDLFVBQVU7SUFDakQsSUFBSUMsZUFBZSxDQUFDLENBQ2xCSCxDQUFBQSxPQUFPSSxNQUFNLElBQ2JKLE9BQU9LLElBQUksSUFDWEwsT0FBT00sT0FBTyxJQUNkTixPQUFPTyxlQUFlLElBQ3RCUCxPQUFPUSxpQ0FBaUMsSUFDeENSLE9BQU9TLGlCQUFpQixJQUN4QlQsT0FBT1MsaUJBQWlCLENBQUNDLFNBQVMsQ0FBQ0MsMEJBQTBCLElBQzdEWCxPQUFPWSxHQUFHLElBQ1ZaLE9BQU9ZLEdBQUcsQ0FBQ0MsZUFBZTtJQUU1QixJQUFJQyxjQUFjLE9BQU9DLFdBQVcsY0FBYyxPQUFPQyxjQUFjO0lBQ3ZFLElBQUlDLGdCQUFnQjtRQUNsQiwyQkFBMkI7UUFDM0IsSUFBSSxDQUFDakIsT0FBT08sZUFBZSxFQUFFO1lBQzNCLE9BQU87UUFDVDtRQUVBLElBQUlXLFNBQVMsSUFBSVgsZ0JBQWdCLEdBQUc7UUFDcEMsSUFBSVksTUFBTUQsT0FBT0UsVUFBVSxDQUFDO1FBQzVCRCxJQUFJRSxRQUFRLENBQUMsR0FBRyxHQUFHLEdBQUc7UUFDdEIsSUFBSUMsU0FBU0osT0FBT0sscUJBQXFCO1FBRXpDLElBQUk7WUFDRkosSUFBSUssYUFBYSxDQUFDRixRQUFRO1FBQzVCLEVBQUUsT0FBT0csR0FBRztZQUNWLE9BQU87UUFDVDtRQUVBLE9BQU87SUFDVDtJQUVBLFNBQVNDLFFBQVE7SUFFakIsaURBQWlEO0lBQ2pELDZCQUE2QjtJQUM3QixTQUFTQyxRQUFRQyxJQUFJO1FBQ25CLElBQUlDLGdCQUFnQi9CLE9BQU9nQyxPQUFPLENBQUN4QixP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QUFNLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9iYXR0bGUtZ3JvdW5kcy8uL25vZGVfbW9kdWxlcy9jYW52YXMtY29uZmV0dGkvZGlzdC9jb25mZXR0aS5tb2R1bGUubWpzP2YxZTQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gY2FudmFzLWNvbmZldHRpIHYxLjkuMyBidWlsdCBvbiAyMDI0LTA0LTMwVDIyOjE5OjE3Ljc5NFpcbnZhciBtb2R1bGUgPSB7fTtcblxuLy8gc291cmNlIGNvbnRlbnRcbi8qIGdsb2JhbHMgTWFwICovXG5cbihmdW5jdGlvbiBtYWluKGdsb2JhbCwgbW9kdWxlLCBpc1dvcmtlciwgd29ya2VyU2l6ZSkge1xuICB2YXIgY2FuVXNlV29ya2VyID0gISEoXG4gICAgZ2xvYmFsLldvcmtlciAmJlxuICAgIGdsb2JhbC5CbG9iICYmXG4gICAgZ2xvYmFsLlByb21pc2UgJiZcbiAgICBnbG9iYWwuT2Zmc2NyZWVuQ2FudmFzICYmXG4gICAgZ2xvYmFsLk9mZnNjcmVlbkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCAmJlxuICAgIGdsb2JhbC5IVE1MQ2FudmFzRWxlbWVudCAmJlxuICAgIGdsb2JhbC5IVE1MQ2FudmFzRWxlbWVudC5wcm90b3R5cGUudHJhbnNmZXJDb250cm9sVG9PZmZzY3JlZW4gJiZcbiAgICBnbG9iYWwuVVJMICYmXG4gICAgZ2xvYmFsLlVSTC5jcmVhdGVPYmplY3RVUkwpO1xuXG4gIHZhciBjYW5Vc2VQYXRocyA9IHR5cGVvZiBQYXRoMkQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIERPTU1hdHJpeCA9PT0gJ2Z1bmN0aW9uJztcbiAgdmFyIGNhbkRyYXdCaXRtYXAgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8vIHRoaXMgbW9zdGx5IHN1cHBvcnRzIHNzclxuICAgIGlmICghZ2xvYmFsLk9mZnNjcmVlbkNhbnZhcykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBjYW52YXMgPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKDEsIDEpO1xuICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBjdHguZmlsbFJlY3QoMCwgMCwgMSwgMSk7XG4gICAgdmFyIGJpdG1hcCA9IGNhbnZhcy50cmFuc2ZlclRvSW1hZ2VCaXRtYXAoKTtcblxuICAgIHRyeSB7XG4gICAgICBjdHguY3JlYXRlUGF0dGVybihiaXRtYXAsICduby1yZXBlYXQnKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0pKCk7XG5cbiAgZnVuY3Rpb24gbm9vcCgpIHt9XG5cbiAgLy8gY3JlYXRlIGEgcHJvbWlzZSBpZiBpdCBleGlzdHMsIG90aGVyd2lzZSwganVzdFxuICAvLyBjYWxsIHRoZSBmdW5jdGlvbiBkaXJlY3RseVxuICBmdW5jdGlvbiBwcm9taXNlKGZ1bmMpIHtcbiAgICB2YXIgTW9kdWxlUHJvbWlzZSA9IG1vZHVsZS5leHBvcnRzLlByb21pc2U7XG4gICAgdmFyIFByb20gPSBNb2R1bGVQcm9taXNlICE9PSB2b2lkIDAgPyBNb2R1bGVQcm9taXNlIDogZ2xvYmFsLlByb21pc2U7XG5cbiAgICBpZiAodHlwZW9mIFByb20gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbShmdW5jKTtcbiAgICB9XG5cbiAgICBmdW5jKG5vb3AsIG5vb3ApO1xuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgYml0bWFwTWFwcGVyID0gKGZ1bmN0aW9uIChza2lwVHJhbnNmb3JtLCBtYXApIHtcbiAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2NhdGRhZC9jYW52YXMtY29uZmV0dGkvaXNzdWVzLzIwOVxuICAgIC8vIGNyZWF0aW5nIGNhbnZhc2VzIGlzIGFjdHVhbGx5IHByZXR0eSBleHBlbnNpdmUsIHNvIHdlIHNob3VsZCBjcmVhdGUgYVxuICAgIC8vIDE6MSBtYXAgZm9yIGJpdG1hcDpjYW52YXMsIHNvIHRoYXQgd2UgY2FuIGFuaW1hdGUgdGhlIGNvbmZldHRpIGluXG4gICAgLy8gYSBwZXJmb3JtYW50IG1hbm5lciwgYnV0IGFsc28gbm90IHN0b3JlIHRoZW0gZm9yZXZlciBzbyB0aGF0IHdlIGRvbid0XG4gICAgLy8gaGF2ZSBhIG1lbW9yeSBsZWFrXG4gICAgcmV0dXJuIHtcbiAgICAgIHRyYW5zZm9ybTogZnVuY3Rpb24oYml0bWFwKSB7XG4gICAgICAgIGlmIChza2lwVHJhbnNmb3JtKSB7XG4gICAgICAgICAgcmV0dXJuIGJpdG1hcDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXAuaGFzKGJpdG1hcCkpIHtcbiAgICAgICAgICByZXR1cm4gbWFwLmdldChiaXRtYXApO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNhbnZhcyA9IG5ldyBPZmZzY3JlZW5DYW52YXMoYml0bWFwLndpZHRoLCBiaXRtYXAuaGVpZ2h0KTtcbiAgICAgICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICBjdHguZHJhd0ltYWdlKGJpdG1hcCwgMCwgMCk7XG5cbiAgICAgICAgbWFwLnNldChiaXRtYXAsIGNhbnZhcyk7XG5cbiAgICAgICAgcmV0dXJuIGNhbnZhcztcbiAgICAgIH0sXG4gICAgICBjbGVhcjogZnVuY3Rpb24gKCkge1xuICAgICAgICBtYXAuY2xlYXIoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KShjYW5EcmF3Qml0bWFwLCBuZXcgTWFwKCkpO1xuXG4gIHZhciByYWYgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBUSU1FID0gTWF0aC5mbG9vcigxMDAwIC8gNjApO1xuICAgIHZhciBmcmFtZSwgY2FuY2VsO1xuICAgIHZhciBmcmFtZXMgPSB7fTtcbiAgICB2YXIgbGFzdEZyYW1lVGltZSA9IDA7XG5cbiAgICBpZiAodHlwZW9mIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgY2FuY2VsQW5pbWF0aW9uRnJhbWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGZyYW1lID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgIHZhciBpZCA9IE1hdGgucmFuZG9tKCk7XG5cbiAgICAgICAgZnJhbWVzW2lkXSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiBvbkZyYW1lKHRpbWUpIHtcbiAgICAgICAgICBpZiAobGFzdEZyYW1lVGltZSA9PT0gdGltZSB8fCBsYXN0RnJhbWVUaW1lICsgVElNRSAtIDEgPCB0aW1lKSB7XG4gICAgICAgICAgICBsYXN0RnJhbWVUaW1lID0gdGltZTtcbiAgICAgICAgICAgIGRlbGV0ZSBmcmFtZXNbaWRdO1xuXG4gICAgICAgICAgICBjYigpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmcmFtZXNbaWRdID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKG9uRnJhbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgfTtcbiAgICAgIGNhbmNlbCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICBpZiAoZnJhbWVzW2lkXSkge1xuICAgICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGZyYW1lc1tpZF0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBmcmFtZSA9IGZ1bmN0aW9uIChjYikge1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChjYiwgVElNRSk7XG4gICAgICB9O1xuICAgICAgY2FuY2VsID0gZnVuY3Rpb24gKHRpbWVyKSB7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4geyBmcmFtZTogZnJhbWUsIGNhbmNlbDogY2FuY2VsIH07XG4gIH0oKSk7XG5cbiAgdmFyIGdldFdvcmtlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHdvcmtlcjtcbiAgICB2YXIgcHJvbTtcbiAgICB2YXIgcmVzb2x2ZXMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGRlY29yYXRlKHdvcmtlcikge1xuICAgICAgZnVuY3Rpb24gZXhlY3V0ZShvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgICB3b3JrZXIucG9zdE1lc3NhZ2UoeyBvcHRpb25zOiBvcHRpb25zIHx8IHt9LCBjYWxsYmFjazogY2FsbGJhY2sgfSk7XG4gICAgICB9XG4gICAgICB3b3JrZXIuaW5pdCA9IGZ1bmN0aW9uIGluaXRXb3JrZXIoY2FudmFzKSB7XG4gICAgICAgIHZhciBvZmZzY3JlZW4gPSBjYW52YXMudHJhbnNmZXJDb250cm9sVG9PZmZzY3JlZW4oKTtcbiAgICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKHsgY2FudmFzOiBvZmZzY3JlZW4gfSwgW29mZnNjcmVlbl0pO1xuICAgICAgfTtcblxuICAgICAgd29ya2VyLmZpcmUgPSBmdW5jdGlvbiBmaXJlV29ya2VyKG9wdGlvbnMsIHNpemUsIGRvbmUpIHtcbiAgICAgICAgaWYgKHByb20pIHtcbiAgICAgICAgICBleGVjdXRlKG9wdGlvbnMsIG51bGwpO1xuICAgICAgICAgIHJldHVybiBwcm9tO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGlkID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMik7XG5cbiAgICAgICAgcHJvbSA9IHByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICBmdW5jdGlvbiB3b3JrZXJEb25lKG1zZykge1xuICAgICAgICAgICAgaWYgKG1zZy5kYXRhLmNhbGxiYWNrICE9PSBpZCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlbGV0ZSByZXNvbHZlc1tpZF07XG4gICAgICAgICAgICB3b3JrZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHdvcmtlckRvbmUpO1xuXG4gICAgICAgICAgICBwcm9tID0gbnVsbDtcblxuICAgICAgICAgICAgYml0bWFwTWFwcGVyLmNsZWFyKCk7XG5cbiAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB3b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHdvcmtlckRvbmUpO1xuICAgICAgICAgIGV4ZWN1dGUob3B0aW9ucywgaWQpO1xuXG4gICAgICAgICAgcmVzb2x2ZXNbaWRdID0gd29ya2VyRG9uZS5iaW5kKG51bGwsIHsgZGF0YTogeyBjYWxsYmFjazogaWQgfX0pO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcHJvbTtcbiAgICAgIH07XG5cbiAgICAgIHdvcmtlci5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0V29ya2VyKCkge1xuICAgICAgICB3b3JrZXIucG9zdE1lc3NhZ2UoeyByZXNldDogdHJ1ZSB9KTtcblxuICAgICAgICBmb3IgKHZhciBpZCBpbiByZXNvbHZlcykge1xuICAgICAgICAgIHJlc29sdmVzW2lkXSgpO1xuICAgICAgICAgIGRlbGV0ZSByZXNvbHZlc1tpZF07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh3b3JrZXIpIHtcbiAgICAgICAgcmV0dXJuIHdvcmtlcjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc1dvcmtlciAmJiBjYW5Vc2VXb3JrZXIpIHtcbiAgICAgICAgdmFyIGNvZGUgPSBbXG4gICAgICAgICAgJ3ZhciBDT05GRVRUSSwgU0laRSA9IHt9LCBtb2R1bGUgPSB7fTsnLFxuICAgICAgICAgICcoJyArIG1haW4udG9TdHJpbmcoKSArICcpKHRoaXMsIG1vZHVsZSwgdHJ1ZSwgU0laRSk7JyxcbiAgICAgICAgICAnb25tZXNzYWdlID0gZnVuY3Rpb24obXNnKSB7JyxcbiAgICAgICAgICAnICBpZiAobXNnLmRhdGEub3B0aW9ucykgeycsXG4gICAgICAgICAgJyAgICBDT05GRVRUSShtc2cuZGF0YS5vcHRpb25zKS50aGVuKGZ1bmN0aW9uICgpIHsnLFxuICAgICAgICAgICcgICAgICBpZiAobXNnLmRhdGEuY2FsbGJhY2spIHsnLFxuICAgICAgICAgICcgICAgICAgIHBvc3RNZXNzYWdlKHsgY2FsbGJhY2s6IG1zZy5kYXRhLmNhbGxiYWNrIH0pOycsXG4gICAgICAgICAgJyAgICAgIH0nLFxuICAgICAgICAgICcgICAgfSk7JyxcbiAgICAgICAgICAnICB9IGVsc2UgaWYgKG1zZy5kYXRhLnJlc2V0KSB7JyxcbiAgICAgICAgICAnICAgIENPTkZFVFRJICYmIENPTkZFVFRJLnJlc2V0KCk7JyxcbiAgICAgICAgICAnICB9IGVsc2UgaWYgKG1zZy5kYXRhLnJlc2l6ZSkgeycsXG4gICAgICAgICAgJyAgICBTSVpFLndpZHRoID0gbXNnLmRhdGEucmVzaXplLndpZHRoOycsXG4gICAgICAgICAgJyAgICBTSVpFLmhlaWdodCA9IG1zZy5kYXRhLnJlc2l6ZS5oZWlnaHQ7JyxcbiAgICAgICAgICAnICB9IGVsc2UgaWYgKG1zZy5kYXRhLmNhbnZhcykgeycsXG4gICAgICAgICAgJyAgICBTSVpFLndpZHRoID0gbXNnLmRhdGEuY2FudmFzLndpZHRoOycsXG4gICAgICAgICAgJyAgICBTSVpFLmhlaWdodCA9IG1zZy5kYXRhLmNhbnZhcy5oZWlnaHQ7JyxcbiAgICAgICAgICAnICAgIENPTkZFVFRJID0gbW9kdWxlLmV4cG9ydHMuY3JlYXRlKG1zZy5kYXRhLmNhbnZhcyk7JyxcbiAgICAgICAgICAnICB9JyxcbiAgICAgICAgICAnfScsXG4gICAgICAgIF0uam9pbignXFxuJyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgd29ya2VyID0gbmV3IFdvcmtlcihVUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFtjb2RlXSkpKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgdHlwZW9mIGNvbnNvbGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgY29uc29sZS53YXJuID09PSAnZnVuY3Rpb24nID8gY29uc29sZS53YXJuKCfwn46KIENvdWxkIG5vdCBsb2FkIHdvcmtlcicsIGUpIDogbnVsbDtcblxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVjb3JhdGUod29ya2VyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHdvcmtlcjtcbiAgICB9O1xuICB9KSgpO1xuXG4gIHZhciBkZWZhdWx0cyA9IHtcbiAgICBwYXJ0aWNsZUNvdW50OiA1MCxcbiAgICBhbmdsZTogOTAsXG4gICAgc3ByZWFkOiA0NSxcbiAgICBzdGFydFZlbG9jaXR5OiA0NSxcbiAgICBkZWNheTogMC45LFxuICAgIGdyYXZpdHk6IDEsXG4gICAgZHJpZnQ6IDAsXG4gICAgdGlja3M6IDIwMCxcbiAgICB4OiAwLjUsXG4gICAgeTogMC41LFxuICAgIHNoYXBlczogWydzcXVhcmUnLCAnY2lyY2xlJ10sXG4gICAgekluZGV4OiAxMDAsXG4gICAgY29sb3JzOiBbXG4gICAgICAnIzI2Y2NmZicsXG4gICAgICAnI2EyNWFmZCcsXG4gICAgICAnI2ZmNWU3ZScsXG4gICAgICAnIzg4ZmY1YScsXG4gICAgICAnI2ZjZmY0MicsXG4gICAgICAnI2ZmYTYyZCcsXG4gICAgICAnI2ZmMzZmZidcbiAgICBdLFxuICAgIC8vIHByb2JhYmx5IHNob3VsZCBiZSB0cnVlLCBidXQgYmFjay1jb21wYXRcbiAgICBkaXNhYmxlRm9yUmVkdWNlZE1vdGlvbjogZmFsc2UsXG4gICAgc2NhbGFyOiAxXG4gIH07XG5cbiAgZnVuY3Rpb24gY29udmVydCh2YWwsIHRyYW5zZm9ybSkge1xuICAgIHJldHVybiB0cmFuc2Zvcm0gPyB0cmFuc2Zvcm0odmFsKSA6IHZhbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzT2sodmFsKSB7XG4gICAgcmV0dXJuICEodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByb3Aob3B0aW9ucywgbmFtZSwgdHJhbnNmb3JtKSB7XG4gICAgcmV0dXJuIGNvbnZlcnQoXG4gICAgICBvcHRpb25zICYmIGlzT2sob3B0aW9uc1tuYW1lXSkgPyBvcHRpb25zW25hbWVdIDogZGVmYXVsdHNbbmFtZV0sXG4gICAgICB0cmFuc2Zvcm1cbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gb25seVBvc2l0aXZlSW50KG51bWJlcil7XG4gICAgcmV0dXJuIG51bWJlciA8IDAgPyAwIDogTWF0aC5mbG9vcihudW1iZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmFuZG9tSW50KG1pbiwgbWF4KSB7XG4gICAgLy8gW21pbiwgbWF4KVxuICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluKSkgKyBtaW47XG4gIH1cblxuICBmdW5jdGlvbiB0b0RlY2ltYWwoc3RyKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHN0ciwgMTYpO1xuICB9XG5cbiAgZnVuY3Rpb24gY29sb3JzVG9SZ2IoY29sb3JzKSB7XG4gICAgcmV0dXJuIGNvbG9ycy5tYXAoaGV4VG9SZ2IpO1xuICB9XG5cbiAgZnVuY3Rpb24gaGV4VG9SZ2Ioc3RyKSB7XG4gICAgdmFyIHZhbCA9IFN0cmluZyhzdHIpLnJlcGxhY2UoL1teMC05YS1mXS9naSwgJycpO1xuXG4gICAgaWYgKHZhbC5sZW5ndGggPCA2KSB7XG4gICAgICAgIHZhbCA9IHZhbFswXSt2YWxbMF0rdmFsWzFdK3ZhbFsxXSt2YWxbMl0rdmFsWzJdO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICByOiB0b0RlY2ltYWwodmFsLnN1YnN0cmluZygwLDIpKSxcbiAgICAgIGc6IHRvRGVjaW1hbCh2YWwuc3Vic3RyaW5nKDIsNCkpLFxuICAgICAgYjogdG9EZWNpbWFsKHZhbC5zdWJzdHJpbmcoNCw2KSlcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0T3JpZ2luKG9wdGlvbnMpIHtcbiAgICB2YXIgb3JpZ2luID0gcHJvcChvcHRpb25zLCAnb3JpZ2luJywgT2JqZWN0KTtcbiAgICBvcmlnaW4ueCA9IHByb3Aob3JpZ2luLCAneCcsIE51bWJlcik7XG4gICAgb3JpZ2luLnkgPSBwcm9wKG9yaWdpbiwgJ3knLCBOdW1iZXIpO1xuXG4gICAgcmV0dXJuIG9yaWdpbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldENhbnZhc1dpbmRvd1NpemUoY2FudmFzKSB7XG4gICAgY2FudmFzLndpZHRoID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0Q2FudmFzUmVjdFNpemUoY2FudmFzKSB7XG4gICAgdmFyIHJlY3QgPSBjYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY2FudmFzLndpZHRoID0gcmVjdC53aWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRDYW52YXMoekluZGV4KSB7XG4gICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuXG4gICAgY2FudmFzLnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJztcbiAgICBjYW52YXMuc3R5bGUudG9wID0gJzBweCc7XG4gICAgY2FudmFzLnN0eWxlLmxlZnQgPSAnMHB4JztcbiAgICBjYW52YXMuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcbiAgICBjYW52YXMuc3R5bGUuekluZGV4ID0gekluZGV4O1xuXG4gICAgcmV0dXJuIGNhbnZhcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGVsbGlwc2UoY29udGV4dCwgeCwgeSwgcmFkaXVzWCwgcmFkaXVzWSwgcm90YXRpb24sIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpQ2xvY2t3aXNlKSB7XG4gICAgY29udGV4dC5zYXZlKCk7XG4gICAgY29udGV4dC50cmFuc2xhdGUoeCwgeSk7XG4gICAgY29udGV4dC5yb3RhdGUocm90YXRpb24pO1xuICAgIGNvbnRleHQuc2NhbGUocmFkaXVzWCwgcmFkaXVzWSk7XG4gICAgY29udGV4dC5hcmMoMCwgMCwgMSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGlDbG9ja3dpc2UpO1xuICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmFuZG9tUGh5c2ljcyhvcHRzKSB7XG4gICAgdmFyIHJhZEFuZ2xlID0gb3B0cy5hbmdsZSAqIChNYXRoLlBJIC8gMTgwKTtcbiAgICB2YXIgcmFkU3ByZWFkID0gb3B0cy5zcHJlYWQgKiAoTWF0aC5QSSAvIDE4MCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgeDogb3B0cy54LFxuICAgICAgeTogb3B0cy55LFxuICAgICAgd29iYmxlOiBNYXRoLnJhbmRvbSgpICogMTAsXG4gICAgICB3b2JibGVTcGVlZDogTWF0aC5taW4oMC4xMSwgTWF0aC5yYW5kb20oKSAqIDAuMSArIDAuMDUpLFxuICAgICAgdmVsb2NpdHk6IChvcHRzLnN0YXJ0VmVsb2NpdHkgKiAwLjUpICsgKE1hdGgucmFuZG9tKCkgKiBvcHRzLnN0YXJ0VmVsb2NpdHkpLFxuICAgICAgYW5nbGUyRDogLXJhZEFuZ2xlICsgKCgwLjUgKiByYWRTcHJlYWQpIC0gKE1hdGgucmFuZG9tKCkgKiByYWRTcHJlYWQpKSxcbiAgICAgIHRpbHRBbmdsZTogKE1hdGgucmFuZG9tKCkgKiAoMC43NSAtIDAuMjUpICsgMC4yNSkgKiBNYXRoLlBJLFxuICAgICAgY29sb3I6IG9wdHMuY29sb3IsXG4gICAgICBzaGFwZTogb3B0cy5zaGFwZSxcbiAgICAgIHRpY2s6IDAsXG4gICAgICB0b3RhbFRpY2tzOiBvcHRzLnRpY2tzLFxuICAgICAgZGVjYXk6IG9wdHMuZGVjYXksXG4gICAgICBkcmlmdDogb3B0cy5kcmlmdCxcbiAgICAgIHJhbmRvbTogTWF0aC5yYW5kb20oKSArIDIsXG4gICAgICB0aWx0U2luOiAwLFxuICAgICAgdGlsdENvczogMCxcbiAgICAgIHdvYmJsZVg6IDAsXG4gICAgICB3b2JibGVZOiAwLFxuICAgICAgZ3Jhdml0eTogb3B0cy5ncmF2aXR5ICogMyxcbiAgICAgIG92YWxTY2FsYXI6IDAuNixcbiAgICAgIHNjYWxhcjogb3B0cy5zY2FsYXIsXG4gICAgICBmbGF0OiBvcHRzLmZsYXRcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRmV0dGkoY29udGV4dCwgZmV0dGkpIHtcbiAgICBmZXR0aS54ICs9IE1hdGguY29zKGZldHRpLmFuZ2xlMkQpICogZmV0dGkudmVsb2NpdHkgKyBmZXR0aS5kcmlmdDtcbiAgICBmZXR0aS55ICs9IE1hdGguc2luKGZldHRpLmFuZ2xlMkQpICogZmV0dGkudmVsb2NpdHkgKyBmZXR0aS5ncmF2aXR5O1xuICAgIGZldHRpLnZlbG9jaXR5ICo9IGZldHRpLmRlY2F5O1xuXG4gICAgaWYgKGZldHRpLmZsYXQpIHtcbiAgICAgIGZldHRpLndvYmJsZSA9IDA7XG4gICAgICBmZXR0aS53b2JibGVYID0gZmV0dGkueCArICgxMCAqIGZldHRpLnNjYWxhcik7XG4gICAgICBmZXR0aS53b2JibGVZID0gZmV0dGkueSArICgxMCAqIGZldHRpLnNjYWxhcik7XG5cbiAgICAgIGZldHRpLnRpbHRTaW4gPSAwO1xuICAgICAgZmV0dGkudGlsdENvcyA9IDA7XG4gICAgICBmZXR0aS5yYW5kb20gPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBmZXR0aS53b2JibGUgKz0gZmV0dGkud29iYmxlU3BlZWQ7XG4gICAgICBmZXR0aS53b2JibGVYID0gZmV0dGkueCArICgoMTAgKiBmZXR0aS5zY2FsYXIpICogTWF0aC5jb3MoZmV0dGkud29iYmxlKSk7XG4gICAgICBmZXR0aS53b2JibGVZID0gZmV0dGkueSArICgoMTAgKiBmZXR0aS5zY2FsYXIpICogTWF0aC5zaW4oZmV0dGkud29iYmxlKSk7XG5cbiAgICAgIGZldHRpLnRpbHRBbmdsZSArPSAwLjE7XG4gICAgICBmZXR0aS50aWx0U2luID0gTWF0aC5zaW4oZmV0dGkudGlsdEFuZ2xlKTtcbiAgICAgIGZldHRpLnRpbHRDb3MgPSBNYXRoLmNvcyhmZXR0aS50aWx0QW5nbGUpO1xuICAgICAgZmV0dGkucmFuZG9tID0gTWF0aC5yYW5kb20oKSArIDI7XG4gICAgfVxuXG4gICAgdmFyIHByb2dyZXNzID0gKGZldHRpLnRpY2srKykgLyBmZXR0aS50b3RhbFRpY2tzO1xuXG4gICAgdmFyIHgxID0gZmV0dGkueCArIChmZXR0aS5yYW5kb20gKiBmZXR0aS50aWx0Q29zKTtcbiAgICB2YXIgeTEgPSBmZXR0aS55ICsgKGZldHRpLnJhbmRvbSAqIGZldHRpLnRpbHRTaW4pO1xuICAgIHZhciB4MiA9IGZldHRpLndvYmJsZVggKyAoZmV0dGkucmFuZG9tICogZmV0dGkudGlsdENvcyk7XG4gICAgdmFyIHkyID0gZmV0dGkud29iYmxlWSArIChmZXR0aS5yYW5kb20gKiBmZXR0aS50aWx0U2luKTtcblxuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJ3JnYmEoJyArIGZldHRpLmNvbG9yLnIgKyAnLCAnICsgZmV0dGkuY29sb3IuZyArICcsICcgKyBmZXR0aS5jb2xvci5iICsgJywgJyArICgxIC0gcHJvZ3Jlc3MpICsgJyknO1xuXG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcblxuICAgIGlmIChjYW5Vc2VQYXRocyAmJiBmZXR0aS5zaGFwZS50eXBlID09PSAncGF0aCcgJiYgdHlwZW9mIGZldHRpLnNoYXBlLnBhdGggPT09ICdzdHJpbmcnICYmIEFycmF5LmlzQXJyYXkoZmV0dGkuc2hhcGUubWF0cml4KSkge1xuICAgICAgY29udGV4dC5maWxsKHRyYW5zZm9ybVBhdGgyRChcbiAgICAgICAgZmV0dGkuc2hhcGUucGF0aCxcbiAgICAgICAgZmV0dGkuc2hhcGUubWF0cml4LFxuICAgICAgICBmZXR0aS54LFxuICAgICAgICBmZXR0aS55LFxuICAgICAgICBNYXRoLmFicyh4MiAtIHgxKSAqIDAuMSxcbiAgICAgICAgTWF0aC5hYnMoeTIgLSB5MSkgKiAwLjEsXG4gICAgICAgIE1hdGguUEkgLyAxMCAqIGZldHRpLndvYmJsZVxuICAgICAgKSk7XG4gICAgfSBlbHNlIGlmIChmZXR0aS5zaGFwZS50eXBlID09PSAnYml0bWFwJykge1xuICAgICAgdmFyIHJvdGF0aW9uID0gTWF0aC5QSSAvIDEwICogZmV0dGkud29iYmxlO1xuICAgICAgdmFyIHNjYWxlWCA9IE1hdGguYWJzKHgyIC0geDEpICogMC4xO1xuICAgICAgdmFyIHNjYWxlWSA9IE1hdGguYWJzKHkyIC0geTEpICogMC4xO1xuICAgICAgdmFyIHdpZHRoID0gZmV0dGkuc2hhcGUuYml0bWFwLndpZHRoICogZmV0dGkuc2NhbGFyO1xuICAgICAgdmFyIGhlaWdodCA9IGZldHRpLnNoYXBlLmJpdG1hcC5oZWlnaHQgKiBmZXR0aS5zY2FsYXI7XG5cbiAgICAgIHZhciBtYXRyaXggPSBuZXcgRE9NTWF0cml4KFtcbiAgICAgICAgTWF0aC5jb3Mocm90YXRpb24pICogc2NhbGVYLFxuICAgICAgICBNYXRoLnNpbihyb3RhdGlvbikgKiBzY2FsZVgsXG4gICAgICAgIC1NYXRoLnNpbihyb3RhdGlvbikgKiBzY2FsZVksXG4gICAgICAgIE1hdGguY29zKHJvdGF0aW9uKSAqIHNjYWxlWSxcbiAgICAgICAgZmV0dGkueCxcbiAgICAgICAgZmV0dGkueVxuICAgICAgXSk7XG5cbiAgICAgIC8vIGFwcGx5IHRoZSB0cmFuc2Zvcm0gbWF0cml4IGZyb20gdGhlIGNvbmZldHRpIHNoYXBlXG4gICAgICBtYXRyaXgubXVsdGlwbHlTZWxmKG5ldyBET01NYXRyaXgoZmV0dGkuc2hhcGUubWF0cml4KSk7XG5cbiAgICAgIHZhciBwYXR0ZXJuID0gY29udGV4dC5jcmVhdGVQYXR0ZXJuKGJpdG1hcE1hcHBlci50cmFuc2Zvcm0oZmV0dGkuc2hhcGUuYml0bWFwKSwgJ25vLXJlcGVhdCcpO1xuICAgICAgcGF0dGVybi5zZXRUcmFuc2Zvcm0obWF0cml4KTtcblxuICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9ICgxIC0gcHJvZ3Jlc3MpO1xuICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBwYXR0ZXJuO1xuICAgICAgY29udGV4dC5maWxsUmVjdChcbiAgICAgICAgZmV0dGkueCAtICh3aWR0aCAvIDIpLFxuICAgICAgICBmZXR0aS55IC0gKGhlaWdodCAvIDIpLFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0XG4gICAgICApO1xuICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IDE7XG4gICAgfSBlbHNlIGlmIChmZXR0aS5zaGFwZSA9PT0gJ2NpcmNsZScpIHtcbiAgICAgIGNvbnRleHQuZWxsaXBzZSA/XG4gICAgICAgIGNvbnRleHQuZWxsaXBzZShmZXR0aS54LCBmZXR0aS55LCBNYXRoLmFicyh4MiAtIHgxKSAqIGZldHRpLm92YWxTY2FsYXIsIE1hdGguYWJzKHkyIC0geTEpICogZmV0dGkub3ZhbFNjYWxhciwgTWF0aC5QSSAvIDEwICogZmV0dGkud29iYmxlLCAwLCAyICogTWF0aC5QSSkgOlxuICAgICAgICBlbGxpcHNlKGNvbnRleHQsIGZldHRpLngsIGZldHRpLnksIE1hdGguYWJzKHgyIC0geDEpICogZmV0dGkub3ZhbFNjYWxhciwgTWF0aC5hYnMoeTIgLSB5MSkgKiBmZXR0aS5vdmFsU2NhbGFyLCBNYXRoLlBJIC8gMTAgKiBmZXR0aS53b2JibGUsIDAsIDIgKiBNYXRoLlBJKTtcbiAgICB9IGVsc2UgaWYgKGZldHRpLnNoYXBlID09PSAnc3RhcicpIHtcbiAgICAgIHZhciByb3QgPSBNYXRoLlBJIC8gMiAqIDM7XG4gICAgICB2YXIgaW5uZXJSYWRpdXMgPSA0ICogZmV0dGkuc2NhbGFyO1xuICAgICAgdmFyIG91dGVyUmFkaXVzID0gOCAqIGZldHRpLnNjYWxhcjtcbiAgICAgIHZhciB4ID0gZmV0dGkueDtcbiAgICAgIHZhciB5ID0gZmV0dGkueTtcbiAgICAgIHZhciBzcGlrZXMgPSA1O1xuICAgICAgdmFyIHN0ZXAgPSBNYXRoLlBJIC8gc3Bpa2VzO1xuXG4gICAgICB3aGlsZSAoc3Bpa2VzLS0pIHtcbiAgICAgICAgeCA9IGZldHRpLnggKyBNYXRoLmNvcyhyb3QpICogb3V0ZXJSYWRpdXM7XG4gICAgICAgIHkgPSBmZXR0aS55ICsgTWF0aC5zaW4ocm90KSAqIG91dGVyUmFkaXVzO1xuICAgICAgICBjb250ZXh0LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgcm90ICs9IHN0ZXA7XG5cbiAgICAgICAgeCA9IGZldHRpLnggKyBNYXRoLmNvcyhyb3QpICogaW5uZXJSYWRpdXM7XG4gICAgICAgIHkgPSBmZXR0aS55ICsgTWF0aC5zaW4ocm90KSAqIGlubmVyUmFkaXVzO1xuICAgICAgICBjb250ZXh0LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgcm90ICs9IHN0ZXA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRleHQubW92ZVRvKE1hdGguZmxvb3IoZmV0dGkueCksIE1hdGguZmxvb3IoZmV0dGkueSkpO1xuICAgICAgY29udGV4dC5saW5lVG8oTWF0aC5mbG9vcihmZXR0aS53b2JibGVYKSwgTWF0aC5mbG9vcih5MSkpO1xuICAgICAgY29udGV4dC5saW5lVG8oTWF0aC5mbG9vcih4MiksIE1hdGguZmxvb3IoeTIpKTtcbiAgICAgIGNvbnRleHQubGluZVRvKE1hdGguZmxvb3IoeDEpLCBNYXRoLmZsb29yKGZldHRpLndvYmJsZVkpKTtcbiAgICB9XG5cbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIGNvbnRleHQuZmlsbCgpO1xuXG4gICAgcmV0dXJuIGZldHRpLnRpY2sgPCBmZXR0aS50b3RhbFRpY2tzO1xuICB9XG5cbiAgZnVuY3Rpb24gYW5pbWF0ZShjYW52YXMsIGZldHRpcywgcmVzaXplciwgc2l6ZSwgZG9uZSkge1xuICAgIHZhciBhbmltYXRpbmdGZXR0aXMgPSBmZXR0aXMuc2xpY2UoKTtcbiAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIHZhciBhbmltYXRpb25GcmFtZTtcbiAgICB2YXIgZGVzdHJveTtcblxuICAgIHZhciBwcm9tID0gcHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgZnVuY3Rpb24gb25Eb25lKCkge1xuICAgICAgICBhbmltYXRpb25GcmFtZSA9IGRlc3Ryb3kgPSBudWxsO1xuXG4gICAgICAgIGNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHNpemUud2lkdGgsIHNpemUuaGVpZ2h0KTtcbiAgICAgICAgYml0bWFwTWFwcGVyLmNsZWFyKCk7XG5cbiAgICAgICAgZG9uZSgpO1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICAgICAgaWYgKGlzV29ya2VyICYmICEoc2l6ZS53aWR0aCA9PT0gd29ya2VyU2l6ZS53aWR0aCAmJiBzaXplLmhlaWdodCA9PT0gd29ya2VyU2l6ZS5oZWlnaHQpKSB7XG4gICAgICAgICAgc2l6ZS53aWR0aCA9IGNhbnZhcy53aWR0aCA9IHdvcmtlclNpemUud2lkdGg7XG4gICAgICAgICAgc2l6ZS5oZWlnaHQgPSBjYW52YXMuaGVpZ2h0ID0gd29ya2VyU2l6ZS5oZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXNpemUud2lkdGggJiYgIXNpemUuaGVpZ2h0KSB7XG4gICAgICAgICAgcmVzaXplcihjYW52YXMpO1xuICAgICAgICAgIHNpemUud2lkdGggPSBjYW52YXMud2lkdGg7XG4gICAgICAgICAgc2l6ZS5oZWlnaHQgPSBjYW52YXMuaGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5jbGVhclJlY3QoMCwgMCwgc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQpO1xuXG4gICAgICAgIGFuaW1hdGluZ0ZldHRpcyA9IGFuaW1hdGluZ0ZldHRpcy5maWx0ZXIoZnVuY3Rpb24gKGZldHRpKSB7XG4gICAgICAgICAgcmV0dXJuIHVwZGF0ZUZldHRpKGNvbnRleHQsIGZldHRpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGFuaW1hdGluZ0ZldHRpcy5sZW5ndGgpIHtcbiAgICAgICAgICBhbmltYXRpb25GcmFtZSA9IHJhZi5mcmFtZSh1cGRhdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9uRG9uZSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGFuaW1hdGlvbkZyYW1lID0gcmFmLmZyYW1lKHVwZGF0ZSk7XG4gICAgICBkZXN0cm95ID0gb25Eb25lO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGFkZEZldHRpczogZnVuY3Rpb24gKGZldHRpcykge1xuICAgICAgICBhbmltYXRpbmdGZXR0aXMgPSBhbmltYXRpbmdGZXR0aXMuY29uY2F0KGZldHRpcyk7XG5cbiAgICAgICAgcmV0dXJuIHByb207XG4gICAgICB9LFxuICAgICAgY2FudmFzOiBjYW52YXMsXG4gICAgICBwcm9taXNlOiBwcm9tLFxuICAgICAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICAgICAgcmFmLmNhbmNlbChhbmltYXRpb25GcmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVzdHJveSkge1xuICAgICAgICAgIGRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBjb25mZXR0aUNhbm5vbihjYW52YXMsIGdsb2JhbE9wdHMpIHtcbiAgICB2YXIgaXNMaWJDYW52YXMgPSAhY2FudmFzO1xuICAgIHZhciBhbGxvd1Jlc2l6ZSA9ICEhcHJvcChnbG9iYWxPcHRzIHx8IHt9LCAncmVzaXplJyk7XG4gICAgdmFyIGhhc1Jlc2l6ZUV2ZW50UmVnaXN0ZXJlZCA9IGZhbHNlO1xuICAgIHZhciBnbG9iYWxEaXNhYmxlRm9yUmVkdWNlZE1vdGlvbiA9IHByb3AoZ2xvYmFsT3B0cywgJ2Rpc2FibGVGb3JSZWR1Y2VkTW90aW9uJywgQm9vbGVhbik7XG4gICAgdmFyIHNob3VsZFVzZVdvcmtlciA9IGNhblVzZVdvcmtlciAmJiAhIXByb3AoZ2xvYmFsT3B0cyB8fCB7fSwgJ3VzZVdvcmtlcicpO1xuICAgIHZhciB3b3JrZXIgPSBzaG91bGRVc2VXb3JrZXIgPyBnZXRXb3JrZXIoKSA6IG51bGw7XG4gICAgdmFyIHJlc2l6ZXIgPSBpc0xpYkNhbnZhcyA/IHNldENhbnZhc1dpbmRvd1NpemUgOiBzZXRDYW52YXNSZWN0U2l6ZTtcbiAgICB2YXIgaW5pdGlhbGl6ZWQgPSAoY2FudmFzICYmIHdvcmtlcikgPyAhIWNhbnZhcy5fX2NvbmZldHRpX2luaXRpYWxpemVkIDogZmFsc2U7XG4gICAgdmFyIHByZWZlckxlc3NNb3Rpb24gPSB0eXBlb2YgbWF0Y2hNZWRpYSA9PT0gJ2Z1bmN0aW9uJyAmJiBtYXRjaE1lZGlhKCcocHJlZmVycy1yZWR1Y2VkLW1vdGlvbiknKS5tYXRjaGVzO1xuICAgIHZhciBhbmltYXRpb25PYmo7XG5cbiAgICBmdW5jdGlvbiBmaXJlTG9jYWwob3B0aW9ucywgc2l6ZSwgZG9uZSkge1xuICAgICAgdmFyIHBhcnRpY2xlQ291bnQgPSBwcm9wKG9wdGlvbnMsICdwYXJ0aWNsZUNvdW50Jywgb25seVBvc2l0aXZlSW50KTtcbiAgICAgIHZhciBhbmdsZSA9IHByb3Aob3B0aW9ucywgJ2FuZ2xlJywgTnVtYmVyKTtcbiAgICAgIHZhciBzcHJlYWQgPSBwcm9wKG9wdGlvbnMsICdzcHJlYWQnLCBOdW1iZXIpO1xuICAgICAgdmFyIHN0YXJ0VmVsb2NpdHkgPSBwcm9wKG9wdGlvbnMsICdzdGFydFZlbG9jaXR5JywgTnVtYmVyKTtcbiAgICAgIHZhciBkZWNheSA9IHByb3Aob3B0aW9ucywgJ2RlY2F5JywgTnVtYmVyKTtcbiAgICAgIHZhciBncmF2aXR5ID0gcHJvcChvcHRpb25zLCAnZ3Jhdml0eScsIE51bWJlcik7XG4gICAgICB2YXIgZHJpZnQgPSBwcm9wKG9wdGlvbnMsICdkcmlmdCcsIE51bWJlcik7XG4gICAgICB2YXIgY29sb3JzID0gcHJvcChvcHRpb25zLCAnY29sb3JzJywgY29sb3JzVG9SZ2IpO1xuICAgICAgdmFyIHRpY2tzID0gcHJvcChvcHRpb25zLCAndGlja3MnLCBOdW1iZXIpO1xuICAgICAgdmFyIHNoYXBlcyA9IHByb3Aob3B0aW9ucywgJ3NoYXBlcycpO1xuICAgICAgdmFyIHNjYWxhciA9IHByb3Aob3B0aW9ucywgJ3NjYWxhcicpO1xuICAgICAgdmFyIGZsYXQgPSAhIXByb3Aob3B0aW9ucywgJ2ZsYXQnKTtcbiAgICAgIHZhciBvcmlnaW4gPSBnZXRPcmlnaW4ob3B0aW9ucyk7XG5cbiAgICAgIHZhciB0ZW1wID0gcGFydGljbGVDb3VudDtcbiAgICAgIHZhciBmZXR0aXMgPSBbXTtcblxuICAgICAgdmFyIHN0YXJ0WCA9IGNhbnZhcy53aWR0aCAqIG9yaWdpbi54O1xuICAgICAgdmFyIHN0YXJ0WSA9IGNhbnZhcy5oZWlnaHQgKiBvcmlnaW4ueTtcblxuICAgICAgd2hpbGUgKHRlbXAtLSkge1xuICAgICAgICBmZXR0aXMucHVzaChcbiAgICAgICAgICByYW5kb21QaHlzaWNzKHtcbiAgICAgICAgICAgIHg6IHN0YXJ0WCxcbiAgICAgICAgICAgIHk6IHN0YXJ0WSxcbiAgICAgICAgICAgIGFuZ2xlOiBhbmdsZSxcbiAgICAgICAgICAgIHNwcmVhZDogc3ByZWFkLFxuICAgICAgICAgICAgc3RhcnRWZWxvY2l0eTogc3RhcnRWZWxvY2l0eSxcbiAgICAgICAgICAgIGNvbG9yOiBjb2xvcnNbdGVtcCAlIGNvbG9ycy5sZW5ndGhdLFxuICAgICAgICAgICAgc2hhcGU6IHNoYXBlc1tyYW5kb21JbnQoMCwgc2hhcGVzLmxlbmd0aCldLFxuICAgICAgICAgICAgdGlja3M6IHRpY2tzLFxuICAgICAgICAgICAgZGVjYXk6IGRlY2F5LFxuICAgICAgICAgICAgZ3Jhdml0eTogZ3Jhdml0eSxcbiAgICAgICAgICAgIGRyaWZ0OiBkcmlmdCxcbiAgICAgICAgICAgIHNjYWxhcjogc2NhbGFyLFxuICAgICAgICAgICAgZmxhdDogZmxhdFxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIHdlIGhhdmUgYSBwcmV2aW91cyBjYW52YXMgYWxyZWFkeSBhbmltYXRpbmcsXG4gICAgICAvLyBhZGQgdG8gaXRcbiAgICAgIGlmIChhbmltYXRpb25PYmopIHtcbiAgICAgICAgcmV0dXJuIGFuaW1hdGlvbk9iai5hZGRGZXR0aXMoZmV0dGlzKTtcbiAgICAgIH1cblxuICAgICAgYW5pbWF0aW9uT2JqID0gYW5pbWF0ZShjYW52YXMsIGZldHRpcywgcmVzaXplciwgc2l6ZSAsIGRvbmUpO1xuXG4gICAgICByZXR1cm4gYW5pbWF0aW9uT2JqLnByb21pc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmlyZShvcHRpb25zKSB7XG4gICAgICB2YXIgZGlzYWJsZUZvclJlZHVjZWRNb3Rpb24gPSBnbG9iYWxEaXNhYmxlRm9yUmVkdWNlZE1vdGlvbiB8fCBwcm9wKG9wdGlvbnMsICdkaXNhYmxlRm9yUmVkdWNlZE1vdGlvbicsIEJvb2xlYW4pO1xuICAgICAgdmFyIHpJbmRleCA9IHByb3Aob3B0aW9ucywgJ3pJbmRleCcsIE51bWJlcik7XG5cbiAgICAgIGlmIChkaXNhYmxlRm9yUmVkdWNlZE1vdGlvbiAmJiBwcmVmZXJMZXNzTW90aW9uKSB7XG4gICAgICAgIHJldHVybiBwcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzTGliQ2FudmFzICYmIGFuaW1hdGlvbk9iaikge1xuICAgICAgICAvLyB1c2UgZXhpc3RpbmcgY2FudmFzIGZyb20gaW4tcHJvZ3Jlc3MgYW5pbWF0aW9uXG4gICAgICAgIGNhbnZhcyA9IGFuaW1hdGlvbk9iai5jYW52YXM7XG4gICAgICB9IGVsc2UgaWYgKGlzTGliQ2FudmFzICYmICFjYW52YXMpIHtcbiAgICAgICAgLy8gY3JlYXRlIGFuZCBpbml0aWFsaXplIGEgbmV3IGNhbnZhc1xuICAgICAgICBjYW52YXMgPSBnZXRDYW52YXMoekluZGV4KTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjYW52YXMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWxsb3dSZXNpemUgJiYgIWluaXRpYWxpemVkKSB7XG4gICAgICAgIC8vIGluaXRpYWxpemUgdGhlIHNpemUgb2YgYSB1c2VyLXN1cHBsaWVkIGNhbnZhc1xuICAgICAgICByZXNpemVyKGNhbnZhcyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzaXplID0ge1xuICAgICAgICB3aWR0aDogY2FudmFzLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IGNhbnZhcy5oZWlnaHRcbiAgICAgIH07XG5cbiAgICAgIGlmICh3b3JrZXIgJiYgIWluaXRpYWxpemVkKSB7XG4gICAgICAgIHdvcmtlci5pbml0KGNhbnZhcyk7XG4gICAgICB9XG5cbiAgICAgIGluaXRpYWxpemVkID0gdHJ1ZTtcblxuICAgICAgaWYgKHdvcmtlcikge1xuICAgICAgICBjYW52YXMuX19jb25mZXR0aV9pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG9uUmVzaXplKCkge1xuICAgICAgICBpZiAod29ya2VyKSB7XG4gICAgICAgICAgLy8gVE9ETyB0aGlzIHJlYWxseSBzaG91bGRuJ3QgYmUgaW1tZWRpYXRlLCBiZWNhdXNlIGl0IGlzIGV4cGVuc2l2ZVxuICAgICAgICAgIHZhciBvYmogPSB7XG4gICAgICAgICAgICBnZXRCb3VuZGluZ0NsaWVudFJlY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgaWYgKCFpc0xpYkNhbnZhcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgcmVzaXplcihvYmopO1xuXG4gICAgICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIHJlc2l6ZToge1xuICAgICAgICAgICAgICB3aWR0aDogb2JqLndpZHRoLFxuICAgICAgICAgICAgICBoZWlnaHQ6IG9iai5oZWlnaHRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBkb24ndCBhY3R1YWxseSBxdWVyeSB0aGUgc2l6ZSBoZXJlLCBzaW5jZSB0aGlzXG4gICAgICAgIC8vIGNhbiBleGVjdXRlIGZyZXF1ZW50bHkgYW5kIHJhcGlkbHlcbiAgICAgICAgc2l6ZS53aWR0aCA9IHNpemUuaGVpZ2h0ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZG9uZSgpIHtcbiAgICAgICAgYW5pbWF0aW9uT2JqID0gbnVsbDtcblxuICAgICAgICBpZiAoYWxsb3dSZXNpemUpIHtcbiAgICAgICAgICBoYXNSZXNpemVFdmVudFJlZ2lzdGVyZWQgPSBmYWxzZTtcbiAgICAgICAgICBnbG9iYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgb25SZXNpemUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzTGliQ2FudmFzICYmIGNhbnZhcykge1xuICAgICAgICAgIGlmIChkb2N1bWVudC5ib2R5LmNvbnRhaW5zKGNhbnZhcykpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoY2FudmFzKTsgXG4gICAgICAgICAgfVxuICAgICAgICAgIGNhbnZhcyA9IG51bGw7XG4gICAgICAgICAgaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYWxsb3dSZXNpemUgJiYgIWhhc1Jlc2l6ZUV2ZW50UmVnaXN0ZXJlZCkge1xuICAgICAgICBoYXNSZXNpemVFdmVudFJlZ2lzdGVyZWQgPSB0cnVlO1xuICAgICAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgb25SZXNpemUsIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHdvcmtlcikge1xuICAgICAgICByZXR1cm4gd29ya2VyLmZpcmUob3B0aW9ucywgc2l6ZSwgZG9uZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmaXJlTG9jYWwob3B0aW9ucywgc2l6ZSwgZG9uZSk7XG4gICAgfVxuXG4gICAgZmlyZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh3b3JrZXIpIHtcbiAgICAgICAgd29ya2VyLnJlc2V0KCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhbmltYXRpb25PYmopIHtcbiAgICAgICAgYW5pbWF0aW9uT2JqLnJlc2V0KCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBmaXJlO1xuICB9XG5cbiAgLy8gTWFrZSBkZWZhdWx0IGV4cG9ydCBsYXp5IHRvIGRlZmVyIHdvcmtlciBjcmVhdGlvbiB1bnRpbCBjYWxsZWQuXG4gIHZhciBkZWZhdWx0RmlyZTtcbiAgZnVuY3Rpb24gZ2V0RGVmYXVsdEZpcmUoKSB7XG4gICAgaWYgKCFkZWZhdWx0RmlyZSkge1xuICAgICAgZGVmYXVsdEZpcmUgPSBjb25mZXR0aUNhbm5vbihudWxsLCB7IHVzZVdvcmtlcjogdHJ1ZSwgcmVzaXplOiB0cnVlIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdEZpcmU7XG4gIH1cblxuICBmdW5jdGlvbiB0cmFuc2Zvcm1QYXRoMkQocGF0aFN0cmluZywgcGF0aE1hdHJpeCwgeCwgeSwgc2NhbGVYLCBzY2FsZVksIHJvdGF0aW9uKSB7XG4gICAgdmFyIHBhdGgyZCA9IG5ldyBQYXRoMkQocGF0aFN0cmluZyk7XG5cbiAgICB2YXIgdDEgPSBuZXcgUGF0aDJEKCk7XG4gICAgdDEuYWRkUGF0aChwYXRoMmQsIG5ldyBET01NYXRyaXgocGF0aE1hdHJpeCkpO1xuXG4gICAgdmFyIHQyID0gbmV3IFBhdGgyRCgpO1xuICAgIC8vIHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRE9NTWF0cml4L0RPTU1hdHJpeFxuICAgIHQyLmFkZFBhdGgodDEsIG5ldyBET01NYXRyaXgoW1xuICAgICAgTWF0aC5jb3Mocm90YXRpb24pICogc2NhbGVYLFxuICAgICAgTWF0aC5zaW4ocm90YXRpb24pICogc2NhbGVYLFxuICAgICAgLU1hdGguc2luKHJvdGF0aW9uKSAqIHNjYWxlWSxcbiAgICAgIE1hdGguY29zKHJvdGF0aW9uKSAqIHNjYWxlWSxcbiAgICAgIHgsXG4gICAgICB5XG4gICAgXSkpO1xuXG4gICAgcmV0dXJuIHQyO1xuICB9XG5cbiAgZnVuY3Rpb24gc2hhcGVGcm9tUGF0aChwYXRoRGF0YSkge1xuICAgIGlmICghY2FuVXNlUGF0aHMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncGF0aCBjb25mZXR0aSBhcmUgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXInKTtcbiAgICB9XG5cbiAgICB2YXIgcGF0aCwgbWF0cml4O1xuXG4gICAgaWYgKHR5cGVvZiBwYXRoRGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHBhdGggPSBwYXRoRGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aCA9IHBhdGhEYXRhLnBhdGg7XG4gICAgICBtYXRyaXggPSBwYXRoRGF0YS5tYXRyaXg7XG4gICAgfVxuXG4gICAgdmFyIHBhdGgyZCA9IG5ldyBQYXRoMkQocGF0aCk7XG4gICAgdmFyIHRlbXBDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICB2YXIgdGVtcEN0eCA9IHRlbXBDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgIGlmICghbWF0cml4KSB7XG4gICAgICAvLyBhdHRlbXB0IHRvIGZpZ3VyZSBvdXQgdGhlIHdpZHRoIG9mIHRoZSBwYXRoLCB1cCB0byAxMDAweDEwMDBcbiAgICAgIHZhciBtYXhTaXplID0gMTAwMDtcbiAgICAgIHZhciBtaW5YID0gbWF4U2l6ZTtcbiAgICAgIHZhciBtaW5ZID0gbWF4U2l6ZTtcbiAgICAgIHZhciBtYXhYID0gMDtcbiAgICAgIHZhciBtYXhZID0gMDtcbiAgICAgIHZhciB3aWR0aCwgaGVpZ2h0O1xuXG4gICAgICAvLyBkbyBzb21lIGxpbmUgc2tpcHBpbmcuLi4gdGhpcyBpcyBmYXN0ZXIgdGhhbiBjaGVja2luZ1xuICAgICAgLy8gZXZlcnkgcGl4ZWwgYW5kIHdpbGwgYmUgbW9zdGx5IHN0aWxsIGNvcnJlY3RcbiAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgbWF4U2l6ZTsgeCArPSAyKSB7XG4gICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgbWF4U2l6ZTsgeSArPSAyKSB7XG4gICAgICAgICAgaWYgKHRlbXBDdHguaXNQb2ludEluUGF0aChwYXRoMmQsIHgsIHksICdub256ZXJvJykpIHtcbiAgICAgICAgICAgIG1pblggPSBNYXRoLm1pbihtaW5YLCB4KTtcbiAgICAgICAgICAgIG1pblkgPSBNYXRoLm1pbihtaW5ZLCB5KTtcbiAgICAgICAgICAgIG1heFggPSBNYXRoLm1heChtYXhYLCB4KTtcbiAgICAgICAgICAgIG1heFkgPSBNYXRoLm1heChtYXhZLCB5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgd2lkdGggPSBtYXhYIC0gbWluWDtcbiAgICAgIGhlaWdodCA9IG1heFkgLSBtaW5ZO1xuXG4gICAgICB2YXIgbWF4RGVzaXJlZFNpemUgPSAxMDtcbiAgICAgIHZhciBzY2FsZSA9IE1hdGgubWluKG1heERlc2lyZWRTaXplL3dpZHRoLCBtYXhEZXNpcmVkU2l6ZS9oZWlnaHQpO1xuXG4gICAgICBtYXRyaXggPSBbXG4gICAgICAgIHNjYWxlLCAwLCAwLCBzY2FsZSxcbiAgICAgICAgLU1hdGgucm91bmQoKHdpZHRoLzIpICsgbWluWCkgKiBzY2FsZSxcbiAgICAgICAgLU1hdGgucm91bmQoKGhlaWdodC8yKSArIG1pblkpICogc2NhbGVcbiAgICAgIF07XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdwYXRoJyxcbiAgICAgIHBhdGg6IHBhdGgsXG4gICAgICBtYXRyaXg6IG1hdHJpeFxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBzaGFwZUZyb21UZXh0KHRleHREYXRhKSB7XG4gICAgdmFyIHRleHQsXG4gICAgICAgIHNjYWxhciA9IDEsXG4gICAgICAgIGNvbG9yID0gJyMwMDAwMDAnLFxuICAgICAgICAvLyBzZWUgaHR0cHM6Ly9ub2xhbmxhd3Nvbi5jb20vMjAyMi8wNC8wOC90aGUtc3RydWdnbGUtb2YtdXNpbmctbmF0aXZlLWVtb2ppLW9uLXRoZS13ZWIvXG4gICAgICAgIGZvbnRGYW1pbHkgPSAnXCJBcHBsZSBDb2xvciBFbW9qaVwiLCBcIlNlZ29lIFVJIEVtb2ppXCIsIFwiU2Vnb2UgVUkgU3ltYm9sXCIsIFwiTm90byBDb2xvciBFbW9qaVwiLCBcIkVtb2ppT25lIENvbG9yXCIsIFwiQW5kcm9pZCBFbW9qaVwiLCBcIlR3ZW1vamkgTW96aWxsYVwiLCBcInN5c3RlbSBlbW9qaVwiLCBzYW5zLXNlcmlmJztcblxuICAgIGlmICh0eXBlb2YgdGV4dERhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0ZXh0ID0gdGV4dERhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRleHQgPSB0ZXh0RGF0YS50ZXh0O1xuICAgICAgc2NhbGFyID0gJ3NjYWxhcicgaW4gdGV4dERhdGEgPyB0ZXh0RGF0YS5zY2FsYXIgOiBzY2FsYXI7XG4gICAgICBmb250RmFtaWx5ID0gJ2ZvbnRGYW1pbHknIGluIHRleHREYXRhID8gdGV4dERhdGEuZm9udEZhbWlseSA6IGZvbnRGYW1pbHk7XG4gICAgICBjb2xvciA9ICdjb2xvcicgaW4gdGV4dERhdGEgPyB0ZXh0RGF0YS5jb2xvciA6IGNvbG9yO1xuICAgIH1cblxuICAgIC8vIGFsbCBvdGhlciBjb25mZXR0aSBhcmUgMTAgcGl4ZWxzLFxuICAgIC8vIHNvIHRoaXMgcGl4ZWwgc2l6ZSBpcyB0aGUgZGUtZmFjdG8gMTAwJSBzY2FsZSBjb25mZXR0aVxuICAgIHZhciBmb250U2l6ZSA9IDEwICogc2NhbGFyO1xuICAgIHZhciBmb250ID0gJycgKyBmb250U2l6ZSArICdweCAnICsgZm9udEZhbWlseTtcblxuICAgIHZhciBjYW52YXMgPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKGZvbnRTaXplLCBmb250U2l6ZSk7XG4gICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgY3R4LmZvbnQgPSBmb250O1xuICAgIHZhciBzaXplID0gY3R4Lm1lYXN1cmVUZXh0KHRleHQpO1xuICAgIHZhciB3aWR0aCA9IE1hdGguY2VpbChzaXplLmFjdHVhbEJvdW5kaW5nQm94UmlnaHQgKyBzaXplLmFjdHVhbEJvdW5kaW5nQm94TGVmdCk7XG4gICAgdmFyIGhlaWdodCA9IE1hdGguY2VpbChzaXplLmFjdHVhbEJvdW5kaW5nQm94QXNjZW50ICsgc2l6ZS5hY3R1YWxCb3VuZGluZ0JveERlc2NlbnQpO1xuXG4gICAgdmFyIHBhZGRpbmcgPSAyO1xuICAgIHZhciB4ID0gc2l6ZS5hY3R1YWxCb3VuZGluZ0JveExlZnQgKyBwYWRkaW5nO1xuICAgIHZhciB5ID0gc2l6ZS5hY3R1YWxCb3VuZGluZ0JveEFzY2VudCArIHBhZGRpbmc7XG4gICAgd2lkdGggKz0gcGFkZGluZyArIHBhZGRpbmc7XG4gICAgaGVpZ2h0ICs9IHBhZGRpbmcgKyBwYWRkaW5nO1xuXG4gICAgY2FudmFzID0gbmV3IE9mZnNjcmVlbkNhbnZhcyh3aWR0aCwgaGVpZ2h0KTtcbiAgICBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBjdHguZm9udCA9IGZvbnQ7XG4gICAgY3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xuXG4gICAgY3R4LmZpbGxUZXh0KHRleHQsIHgsIHkpO1xuXG4gICAgdmFyIHNjYWxlID0gMSAvIHNjYWxhcjtcblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnYml0bWFwJyxcbiAgICAgIC8vIFRPRE8gdGhlc2UgcHJvYmFibHkgbmVlZCB0byBiZSB0cmFuc2ZlcmVkIGZvciB3b3JrZXJzXG4gICAgICBiaXRtYXA6IGNhbnZhcy50cmFuc2ZlclRvSW1hZ2VCaXRtYXAoKSxcbiAgICAgIG1hdHJpeDogW3NjYWxlLCAwLCAwLCBzY2FsZSwgLXdpZHRoICogc2NhbGUgLyAyLCAtaGVpZ2h0ICogc2NhbGUgLyAyXVxuICAgIH07XG4gIH1cblxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBnZXREZWZhdWx0RmlyZSgpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG4gIG1vZHVsZS5leHBvcnRzLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgZ2V0RGVmYXVsdEZpcmUoKS5yZXNldCgpO1xuICB9O1xuICBtb2R1bGUuZXhwb3J0cy5jcmVhdGUgPSBjb25mZXR0aUNhbm5vbjtcbiAgbW9kdWxlLmV4cG9ydHMuc2hhcGVGcm9tUGF0aCA9IHNoYXBlRnJvbVBhdGg7XG4gIG1vZHVsZS5leHBvcnRzLnNoYXBlRnJvbVRleHQgPSBzaGFwZUZyb21UZXh0O1xufSgoZnVuY3Rpb24gKCkge1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gd2luZG93O1xuICB9XG5cbiAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBzZWxmO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMgfHwge307XG59KSgpLCBtb2R1bGUsIGZhbHNlKSk7XG5cbi8vIGVuZCBzb3VyY2UgY29udGVudFxuXG5leHBvcnQgZGVmYXVsdCBtb2R1bGUuZXhwb3J0cztcbmV4cG9ydCB2YXIgY3JlYXRlID0gbW9kdWxlLmV4cG9ydHMuY3JlYXRlO1xuIl0sIm5hbWVzIjpbIm1vZHVsZSIsIm1haW4iLCJnbG9iYWwiLCJpc1dvcmtlciIsIndvcmtlclNpemUiLCJjYW5Vc2VXb3JrZXIiLCJXb3JrZXIiLCJCbG9iIiwiUHJvbWlzZSIsIk9mZnNjcmVlbkNhbnZhcyIsIk9mZnNjcmVlbkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCIsIkhUTUxDYW52YXNFbGVtZW50IiwicHJvdG90eXBlIiwidHJhbnNmZXJDb250cm9sVG9PZmZzY3JlZW4iLCJVUkwiLCJjcmVhdGVPYmplY3RVUkwiLCJjYW5Vc2VQYXRocyIsIlBhdGgyRCIsIkRPTU1hdHJpeCIsImNhbkRyYXdCaXRtYXAiLCJjYW52YXMiLCJjdHgiLCJnZXRDb250ZXh0IiwiZmlsbFJlY3QiLCJiaXRtYXAiLCJ0cmFuc2ZlclRvSW1hZ2VCaXRtYXAiLCJjcmVhdGVQYXR0ZXJuIiwiZSIsIm5vb3AiLCJwcm9taXNlIiwiZnVuYyIsIk1vZHVsZVByb21pc2UiLCJleHBvcnRzIiwiUHJvbSIsImJpdG1hcE1hcHBlciIsInNraXBUcmFuc2Zvcm0iLCJtYXAiLCJ0cmFuc2Zvcm0iLCJoYXMiLCJnZXQiLCJ3aWR0aCIsImhlaWdodCIsImRyYXdJbWFnZSIsInNldCIsImNsZWFyIiwiTWFwIiwicmFmIiwiVElNRSIsIk1hdGgiLCJmbG9vciIsImZyYW1lIiwiY2FuY2VsIiwiZnJhbWVzIiwibGFzdEZyYW1lVGltZSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwiY2IiLCJpZCIsInJhbmRvbSIsIm9uRnJhbWUiLCJ0aW1lIiwic2V0VGltZW91dCIsInRpbWVyIiwiY2xlYXJUaW1lb3V0IiwiZ2V0V29ya2VyIiwid29ya2VyIiwicHJvbSIsInJlc29sdmVzIiwiZGVjb3JhdGUiLCJleGVjdXRlIiwib3B0aW9ucyIsImNhbGxiYWNrIiwicG9zdE1lc3NhZ2UiLCJpbml0IiwiaW5pdFdvcmtlciIsIm9mZnNjcmVlbiIsImZpcmUiLCJmaXJlV29ya2VyIiwic2l6ZSIsImRvbmUiLCJ0b1N0cmluZyIsInNsaWNlIiwicmVzb2x2ZSIsIndvcmtlckRvbmUiLCJtc2ciLCJkYXRhIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImFkZEV2ZW50TGlzdGVuZXIiLCJiaW5kIiwicmVzZXQiLCJyZXNldFdvcmtlciIsImNvZGUiLCJqb2luIiwiY29uc29sZSIsInVuZGVmaW5lZCIsIndhcm4iLCJkZWZhdWx0cyIsInBhcnRpY2xlQ291bnQiLCJhbmdsZSIsInNwcmVhZCIsInN0YXJ0VmVsb2NpdHkiLCJkZWNheSIsImdyYXZpdHkiLCJkcmlmdCIsInRpY2tzIiwieCIsInkiLCJzaGFwZXMiLCJ6SW5kZXgiLCJjb2xvcnMiLCJkaXNhYmxlRm9yUmVkdWNlZE1vdGlvbiIsInNjYWxhciIsImNvbnZlcnQiLCJ2YWwiLCJpc09rIiwicHJvcCIsIm5hbWUiLCJvbmx5UG9zaXRpdmVJbnQiLCJudW1iZXIiLCJyYW5kb21JbnQiLCJtaW4iLCJtYXgiLCJ0b0RlY2ltYWwiLCJzdHIiLCJwYXJzZUludCIsImNvbG9yc1RvUmdiIiwiaGV4VG9SZ2IiLCJTdHJpbmciLCJyZXBsYWNlIiwibGVuZ3RoIiwiciIsInN1YnN0cmluZyIsImciLCJiIiwiZ2V0T3JpZ2luIiwib3JpZ2luIiwiT2JqZWN0IiwiTnVtYmVyIiwic2V0Q2FudmFzV2luZG93U2l6ZSIsImRvY3VtZW50IiwiZG9jdW1lbnRFbGVtZW50IiwiY2xpZW50V2lkdGgiLCJjbGllbnRIZWlnaHQiLCJzZXRDYW52YXNSZWN0U2l6ZSIsInJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJnZXRDYW52YXMiLCJjcmVhdGVFbGVtZW50Iiwic3R5bGUiLCJwb3NpdGlvbiIsInRvcCIsImxlZnQiLCJwb2ludGVyRXZlbnRzIiwiZWxsaXBzZSIsImNvbnRleHQiLCJyYWRpdXNYIiwicmFkaXVzWSIsInJvdGF0aW9uIiwic3RhcnRBbmdsZSIsImVuZEFuZ2xlIiwiYW50aUNsb2Nrd2lzZSIsInNhdmUiLCJ0cmFuc2xhdGUiLCJyb3RhdGUiLCJzY2FsZSIsImFyYyIsInJlc3RvcmUiLCJyYW5kb21QaHlzaWNzIiwib3B0cyIsInJhZEFuZ2xlIiwiUEkiLCJyYWRTcHJlYWQiLCJ3b2JibGUiLCJ3b2JibGVTcGVlZCIsInZlbG9jaXR5IiwiYW5nbGUyRCIsInRpbHRBbmdsZSIsImNvbG9yIiwic2hhcGUiLCJ0aWNrIiwidG90YWxUaWNrcyIsInRpbHRTaW4iLCJ0aWx0Q29zIiwid29iYmxlWCIsIndvYmJsZVkiLCJvdmFsU2NhbGFyIiwiZmxhdCIsInVwZGF0ZUZldHRpIiwiZmV0dGkiLCJjb3MiLCJzaW4iLCJwcm9ncmVzcyIsIngxIiwieTEiLCJ4MiIsInkyIiwiZmlsbFN0eWxlIiwiYmVnaW5QYXRoIiwidHlwZSIsInBhdGgiLCJBcnJheSIsImlzQXJyYXkiLCJtYXRyaXgiLCJmaWxsIiwidHJhbnNmb3JtUGF0aDJEIiwiYWJzIiwic2NhbGVYIiwic2NhbGVZIiwibXVsdGlwbHlTZWxmIiwicGF0dGVybiIsInNldFRyYW5zZm9ybSIsImdsb2JhbEFscGhhIiwicm90IiwiaW5uZXJSYWRpdXMiLCJvdXRlclJhZGl1cyIsInNwaWtlcyIsInN0ZXAiLCJsaW5lVG8iLCJtb3ZlVG8iLCJjbG9zZVBhdGgiLCJhbmltYXRlIiwiZmV0dGlzIiwicmVzaXplciIsImFuaW1hdGluZ0ZldHRpcyIsImFuaW1hdGlvbkZyYW1lIiwiZGVzdHJveSIsIm9uRG9uZSIsImNsZWFyUmVjdCIsInVwZGF0ZSIsImZpbHRlciIsImFkZEZldHRpcyIsImNvbmNhdCIsImNvbmZldHRpQ2Fubm9uIiwiZ2xvYmFsT3B0cyIsImlzTGliQ2FudmFzIiwiYWxsb3dSZXNpemUiLCJoYXNSZXNpemVFdmVudFJlZ2lzdGVyZWQiLCJnbG9iYWxEaXNhYmxlRm9yUmVkdWNlZE1vdGlvbiIsIkJvb2xlYW4iLCJzaG91bGRVc2VXb3JrZXIiLCJpbml0aWFsaXplZCIsIl9fY29uZmV0dGlfaW5pdGlhbGl6ZWQiLCJwcmVmZXJMZXNzTW90aW9uIiwibWF0Y2hNZWRpYSIsIm1hdGNoZXMiLCJhbmltYXRpb25PYmoiLCJmaXJlTG9jYWwiLCJ0ZW1wIiwic3RhcnRYIiwic3RhcnRZIiwicHVzaCIsImJvZHkiLCJhcHBlbmRDaGlsZCIsIm9uUmVzaXplIiwib2JqIiwicmVzaXplIiwiY29udGFpbnMiLCJyZW1vdmVDaGlsZCIsImRlZmF1bHRGaXJlIiwiZ2V0RGVmYXVsdEZpcmUiLCJ1c2VXb3JrZXIiLCJwYXRoU3RyaW5nIiwicGF0aE1hdHJpeCIsInBhdGgyZCIsInQxIiwiYWRkUGF0aCIsInQyIiwic2hhcGVGcm9tUGF0aCIsInBhdGhEYXRhIiwiRXJyb3IiLCJ0ZW1wQ2FudmFzIiwidGVtcEN0eCIsIm1heFNpemUiLCJtaW5YIiwibWluWSIsIm1heFgiLCJtYXhZIiwiaXNQb2ludEluUGF0aCIsIm1heERlc2lyZWRTaXplIiwicm91bmQiLCJzaGFwZUZyb21UZXh0IiwidGV4dERhdGEiLCJ0ZXh0IiwiZm9udEZhbWlseSIsImZvbnRTaXplIiwiZm9udCIsIm1lYXN1cmVUZXh0IiwiY2VpbCIsImFjdHVhbEJvdW5kaW5nQm94UmlnaHQiLCJhY3R1YWxCb3VuZGluZ0JveExlZnQiLCJhY3R1YWxCb3VuZGluZ0JveEFzY2VudCIsImFjdHVhbEJvdW5kaW5nQm94RGVzY2VudCIsInBhZGRpbmciLCJmaWxsVGV4dCIsImFwcGx5IiwiYXJndW1lbnRzIiwiY3JlYXRlIiwid2luZG93Iiwic2VsZiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/canvas-confetti/dist/confetti.module.mjs\n");

/***/ })

};
;